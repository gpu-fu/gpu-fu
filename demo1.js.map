{"version":3,"file":"demo1.js","mappings":"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","sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/webpack/runtime/make namespace object","webpack://beta/../gpu-fu/src/Property.ts","webpack://beta/../gpu-fu/src/Derived.ts","webpack://beta/../gpu-fu/src/Operation.ts","webpack://beta/../gpu-fu/src/Effect.ts","webpack://beta/../gpu-fu/src/Context.ts","webpack://beta/../incubator/src/OutputCanvas.ts","webpack://beta/./src/runDemo.ts","webpack://beta/./src/demo1.wgsl","webpack://beta/./src/demo1.ts","webpack://beta/../gpu-fu/src/hooks.ts","webpack://beta/../gpu-fu/src/Unit.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { ContextImplementation } from \"./Context\"\nimport { Operation } from \"./Operation\"\n\nexport type Property<T> = Pick<\n  PropertyImplementation<T>,\n  | \"current\"\n  | \"getNonReactively\"\n  | \"readOnly\"\n  | \"set\"\n  | \"setAndNotify\"\n  | \"change\"\n  | \"mutate\"\n  | \"_runIfNeededAt\"\n  | \"_produceIfNeededAt\"\n  | \"_attachProducerOperation\"\n>\n\nexport type PropertyReadOnly<T> = Pick<\n  PropertyImplementation<T>,\n  | \"current\"\n  | \"getNonReactively\"\n  | \"_runIfNeededAt\"\n  | \"_produceIfNeededAt\"\n  | \"_attachProducerOperation\"\n>\n\nexport class PropertyImplementation<T> implements Property<T> {\n  private _ctx: ContextImplementation\n  _current: T // TODO: private\n  private _next: T\n  private _changeAtNextTick = false\n  private _changedClockNumber = 0\n  private _producedClockNumber = 0\n  private _producerOperations: Operation[] = []\n\n  constructor(initialValue: T, ctx: ContextImplementation) {\n    this._current = initialValue\n    this._next = initialValue\n    this._ctx = ctx\n  }\n\n  _attachProducerOperation(op: Operation): void {\n    this._producerOperations.push(op)\n  }\n\n  _runIfNeededAt(clockNumber: number): boolean {\n    if (!this._changeAtNextTick) return this._changedClockNumber >= clockNumber\n\n    this._current = this._next\n    this._changeAtNextTick = false\n    this._changedClockNumber = clockNumber\n\n    return true\n  }\n\n  _produceIfNeededAt(clockNumber: number) {\n    if (this._producedClockNumber >= clockNumber) return\n\n    this._producerOperations.forEach((op) => op._produceIfNeededAt(clockNumber))\n    this._producedClockNumber = clockNumber\n  }\n\n  // Get the current value of the property.\n  //\n  // This can only be accessed from within a reactive context,\n  // since it implies that you want to track the property as a dependency\n  // dependency that will cause the reactive context to be called again.\n  // To get the current value non-reactively, call `getNonReactively` instead.\n  get current(): T {\n    const currentAction = this._ctx._currentAction\n    if (!currentAction)\n      throw new Error(\n        \"It's only possible to read properties from within a reactive context\",\n      )\n    currentAction._attachDependency(this)\n\n    return this._current\n  }\n\n  // Get the current value of the property without dependency tracking.\n  // Unlike the `current` getter, this can be called anywhere,\n  // both in contexts which are reactive and non-reactive.\n  // But if called in a reactive context, there is no dependency link created.\n  getNonReactively(): T {\n    return this._current\n  }\n\n  // Get a version of this property accessor that can only read (in TypeScript).\n  get readOnly(): PropertyReadOnly<T> {\n    return this\n  }\n\n  // Assign a new value to the property, notifying any reactive effects if\n  // (and only if) the new value is not referentially identical to the old one.\n  //\n  // Use `setAndNotify` instead if you want to unconditionally notify all\n  // downstream reactive effects even if the new value is the same.\n  set(newValue: T) {\n    if (this._current !== newValue) this.setAndNotify(newValue)\n  }\n\n  // Assign a new value to the property, notifying all reactive effects,\n  // regardless of whether the new value is referentially identical to the old.\n  //\n  // Usually you want to use `set` instead, which checks referential identity.\n  setAndNotify(newValue: T) {\n    this._next = newValue\n    this.notify()\n  }\n\n  // Use a function to change the value of the property based on the current\n  // value (which will be passed as the argument to the function).\n  //\n  // All reactive effects will be notified if (and only if) the new value\n  // produced by the function is not referentially identical to the old value.\n  //\n  // Use `mutate` instead if the value is an object type that you want to mutate\n  // to change it and trigger reactive effects without actually having to\n  // produce a new referentially new object for the new value.\n  change(fn: (currentValue: T) => T) {\n    this.set(fn(this._current))\n  }\n\n  // Use a function to mutate the current value of the property,\n  // without changing its referential identity.\n  //\n  // All reactive effects will be notified regardless of what the function does.\n  mutate(fn: (currentValue: T) => unknown) {\n    fn(this._current)\n    this.notify() // assume mutation always happens\n  }\n\n  private notify() {\n    this._changeAtNextTick = true\n  }\n}\n","import { ContextImplementation } from \"./Context\"\nimport { Operation } from \"./Operation\"\nimport { PropertyReadOnly } from \"./Property\"\n\nexport type Derived<T> = PropertyReadOnly<T>\n\nexport class DerivedImplementation<T> implements Derived<T> {\n  _ctx: ContextImplementation\n  _fn: (ctx: unknown) => T\n  _deps = new Set<PropertyReadOnly<unknown>>()\n  _cachedResult?: T\n  _cachedClockNumber: number = 0\n  _producedClockNumber = 0\n  _producerOperations: Operation[] = []\n\n  constructor(ctx: ContextImplementation, fn: (ctx: unknown) => T) {\n    this._ctx = ctx\n    this._fn = fn\n  }\n\n  _attachDependency(dep: PropertyReadOnly<unknown>): void {\n    this._deps.add(dep)\n  }\n\n  _attachProducerOperation(op: Operation): void {\n    this._producerOperations.push(op)\n  }\n\n  _runIfNeededAt(clockNumber: number): boolean {\n    if (this._cachedClockNumber >= clockNumber) return true\n\n    var depsChanged = false\n    this._deps.forEach((dep) => {\n      if (dep._runIfNeededAt(clockNumber)) depsChanged = true\n    })\n    if (!depsChanged && this._cachedClockNumber > 0) return false\n\n    const outerAction = this._ctx._currentAction\n    this._ctx._currentAction = this\n\n    // Run the destroy method of the previous result to clean up if applicable.\n    const previousResult = this._cachedResult\n    if (\n      typeof previousResult === \"object\" &&\n      \"destroy\" in previousResult &&\n      typeof (previousResult as any).destroy === \"function\"\n    ) {\n      ;(previousResult as any).destroy()\n    }\n\n    this._cachedResult = this._fn(this._ctx)\n    this._cachedClockNumber = clockNumber\n\n    this._ctx._currentAction = outerAction\n\n    return true\n  }\n\n  _produceIfNeededAt(clockNumber: number) {\n    if (this._producedClockNumber >= clockNumber) return\n\n    this._producerOperations.forEach((op) => op._produceIfNeededAt(clockNumber))\n    this._producedClockNumber = clockNumber\n  }\n\n  get current(): T {\n    const currentDerived = this._ctx._currentAction\n    if (!currentDerived)\n      throw new Error(\n        \"It's only possible to read properties from within a reactive context\",\n      )\n    currentDerived._attachDependency(this)\n\n    this._runIfNeededAt(this._ctx._currentClockNumber)\n\n    return this._cachedResult as T\n  }\n\n  getNonReactively(): T {\n    return this._cachedResult as T\n  }\n}\n","import { ContextImplementation } from \"./Context\"\nimport { PropertyReadOnly } from \"./Property\"\n\nexport type Operation = Pick<\n  OperationImplementation,\n  \"_produceIfNeededAt\" | \"_attachDependency\"\n>\n\nexport class OperationImplementation implements Operation {\n  _ctx: ContextImplementation\n  _fn: (ctx: unknown) => void\n  _deps = new Set<PropertyReadOnly<unknown>>()\n  _producedClockNumber: number = 0\n\n  constructor(ctx: ContextImplementation, fn: (ctx: unknown) => void) {\n    this._ctx = ctx\n    this._fn = fn\n  }\n\n  _attachDependency(dep: PropertyReadOnly<unknown>): void {\n    this._deps.add(dep)\n  }\n\n  _produceIfNeededAt(clockNumber: number) {\n    if (this._producedClockNumber >= clockNumber) return\n    this._producedClockNumber = clockNumber\n\n    this._deps.forEach((op) => op._runIfNeededAt(clockNumber))\n    this._deps.forEach((op) => op._produceIfNeededAt(clockNumber))\n\n    const outerAction = this._ctx._currentAction\n    this._ctx._currentAction = this\n\n    this._fn(this._ctx)\n\n    this._ctx._currentAction = outerAction\n  }\n}\n","import { ContextImplementation } from \"./Context\"\nimport { PropertyReadOnly } from \"./Property\"\n\nexport type Effect = Pick<\n  EffectImplementation,\n  \"_attachDependency\" | \"_runIfNeededAt\"\n>\n\nexport class EffectImplementation implements Effect {\n  _ctx: ContextImplementation\n  _fn: (ctx: unknown) => (() => {}) | undefined\n  _deps = new Set<PropertyReadOnly<unknown>>()\n  _lastCancelFn?: () => {}\n  _lastClockNumber = 0\n\n  constructor(\n    ctx: ContextImplementation,\n    fn: (ctx: unknown) => (() => {}) | undefined,\n  ) {\n    this._ctx = ctx\n    this._fn = fn\n  }\n\n  _attachDependency(dep: PropertyReadOnly<unknown>): void {\n    this._deps.add(dep)\n  }\n\n  _runIfNeededAt(clockNumber: number) {\n    if (this._lastClockNumber >= clockNumber) return true\n\n    var depsChanged = false\n    this._deps.forEach((dep) => {\n      if (dep._runIfNeededAt(clockNumber)) depsChanged = true\n    })\n    if (!depsChanged && this._lastClockNumber > 0) return false\n\n    const lastCancelFn = this._lastCancelFn\n    if (lastCancelFn) lastCancelFn()\n\n    const outerAction = this._ctx._currentAction\n    this._ctx._currentAction = this\n\n    this._lastCancelFn = this._fn(this._ctx)\n\n    this._ctx._currentAction = outerAction\n    this._lastClockNumber = clockNumber\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Unit } from \"./Unit\"\nimport { Property, PropertyImplementation, PropertyReadOnly } from \"./Property\"\nimport { Derived, DerivedImplementation } from \"./Derived\"\nimport { OperationImplementation } from \"./Operation\"\nimport { EffectImplementation } from \"./Effect\"\nimport { Effect } from \"./Effect\"\n\nexport type MaybeDestroyableGPUResource =\n  | undefined\n  | 0\n  | false\n  | null\n  | (GPUObjectBase & { destroy?: () => void })\n\ntype AttachDependency = Pick<\n  DerivedImplementation<unknown>,\n  \"_attachDependency\"\n>\n\nexport class ContextImplementation {\n  _currentAction?: AttachDependency\n  _currentClockNumber: number = 1\n\n  _effects: Effect[] = []\n\n  _device: GPUDevice\n  _commandEncoder?: GPUCommandEncoder\n\n  constructor(device: GPUDevice) {\n    this._device = device\n  }\n\n  get commandEncoder(): GPUCommandEncoder | undefined {\n    return this._commandEncoder\n  }\n\n  get device(): GPUDevice {\n    return this._device\n  }\n\n  _useProp<T>(initialValue: (() => T) | T): Property<T> {\n    return new PropertyImplementation<T>(\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue,\n      this,\n    )\n  }\n\n  _useGPUResource<T extends MaybeDestroyableGPUResource>(\n    fn: (ctx: ContextForGPUResource) => T,\n  ): Derived<T> {\n    return new DerivedImplementation<T>(this, fn as any)\n  }\n\n  _useGPUUpdate(\n    producedProps: PropertyReadOnly<unknown>[],\n    fn: (ctx: ContextForGPUAction) => void,\n  ) {\n    const op = new OperationImplementation(this, fn as any)\n\n    producedProps.forEach((prop) => prop._attachProducerOperation(op))\n  }\n\n  _useEffect(fn: (ctx: ContextEmpty) => (() => void) | undefined) {\n    this._effects.push(new EffectImplementation(this, fn as any))\n  }\n}\n\nexport type Context = Pick<\n  ContextImplementation,\n  // In the main function context, hooks are available.\n  \"device\" | \"_useProp\" | \"_useGPUResource\" | \"_useGPUUpdate\" | \"_useEffect\"\n>\n\nexport type ContextForGPUResource = Pick<\n  ContextImplementation,\n  // No hooks are available.\n  \"device\"\n>\n\nexport type ContextForGPUAction = Pick<\n  ContextImplementation,\n  // No hooks are available, but a command encoder is available.\n  \"device\"\n> & { commandEncoder: GPUCommandEncoder }\n\nexport type ContextEmpty = {}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Render, UnitRoot } from \"@gpu-fu/gpu-fu\"\n\nexport default class OutputCanvas {\n  _canvasContext: GPUCanvasContext\n  _renders: UnitRoot<Render>[] = []\n\n  constructor(canvasContext: GPUCanvasContext) {\n    this._canvasContext = canvasContext\n  }\n\n  addRender(render: UnitRoot<Render>) {\n    if (this._renders.includes(render)) return\n    this._renders.push(render)\n  }\n\n  outputFrame(commandEncoder: GPUCommandEncoder) {\n    const target = this._canvasContext.getCurrentTexture()\n    this._renders.forEach((render) => {\n      render.renderTarget.setAndNotify(target)\n      render.runFrame(commandEncoder, [render.renderTarget])\n    })\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { UnitFn, createUnitRoot, Render } from \"@gpu-fu/gpu-fu\"\nimport { OutputCanvas } from \"@gpu-fu/incubator\"\n\ntype FrameFn = (commandEncoder: GPUCommandEncoder) => void\ntype SetupFn = (device: GPUDevice, canvasContext: GPUCanvasContext) => FrameFn\n\nexport default function runDemo(renderFn: UnitFn<Render>) {\n  runDemoInner((device, canvasContext) => {\n    const render = createUnitRoot(device, renderFn)\n\n    const output = new OutputCanvas(canvasContext)\n    output.addRender(render)\n\n    return function frame(commandEncoder) {\n      output.outputFrame(commandEncoder)\n    }\n  })\n}\n\nfunction runDemoInner(setupFn: SetupFn) {\n  ;(async () => {\n    const device = await getDevice()\n    const canvasContext = await getCanvasContext(getDemoCanvas(), device)\n\n    const frameFn = setupFn(device, canvasContext)\n\n    function repeatFrameWithContext() {\n      runFrameWithContext(device, frameFn)\n      requestAnimationFrame(repeatFrameWithContext)\n    }\n    requestAnimationFrame(repeatFrameWithContext)\n  })().catch((error) => {\n    document.querySelector(\"body\")!.innerHTML = error\n    console.error(error)\n  })\n}\n\nasync function getDevice(\n  powerPreference: GPUPowerPreference = \"high-performance\",\n): Promise<GPUDevice> {\n  if (!navigator.gpu)\n    throw new Error(\"Your browser doesn't have WebGPU enabled!\")\n\n  const gpu = await navigator.gpu.requestAdapter({ powerPreference })\n  if (!gpu) throw new Error(\"Failed to get the GPU adapter!\")\n\n  return gpu.requestDevice()\n}\n\nexport function getDemoCanvas(): HTMLCanvasElement {\n  const canvas = document.querySelector(\n    \"canvas.main\",\n  ) as HTMLCanvasElement | null\n  if (!canvas) throw new Error(\"The main canvas wasn't found in the HTML!\")\n\n  return canvas\n}\n\nasync function getCanvasContext(\n  canvas: HTMLCanvasElement,\n  device: GPUDevice,\n): Promise<GPUCanvasContext> {\n  const canvasContext = canvas.getContext(\"webgpu\") as GPUCanvasContext | null\n  if (!canvasContext) throw new Error(\"Failed to get a WebGPU canvas context!\")\n\n  canvasContext.configure({\n    device,\n    format: getPreferredCanvasFormat(),\n    alphaMode: \"opaque\",\n    compositingAlphaMode: \"opaque\",\n  })\n\n  return canvasContext\n}\n\nfunction getPreferredCanvasFormat() {\n  // Some browsers throw an \"Illegal invocation\" error if we don't bind.\n  const getPreferredCanvasFormat =\n    navigator.gpu?.getPreferredCanvasFormat?.bind(navigator.gpu)\n  if (getPreferredCanvasFormat) return getPreferredCanvasFormat()\n\n  // Hard-coded default for browsers that don't implement this function yet.\n  return \"rgba8unorm\"\n}\n\nfunction runFrameWithContext(device: GPUDevice, frameFn: FrameFn) {\n  const commandEncoder = device.createCommandEncoder()\n  frameFn(commandEncoder)\n  device.queue.submit([commandEncoder.finish()])\n}\n","export default \"@stage(vertex)\\nfn vertexRenderColoredTriangle(\\n  @builtin(vertex_index) index: u32\\n) ->\\n  @builtin(position) vec4<f32>\\n{\\n  let triangle = array<vec2<f32>, 3>(\\n    vec2<f32>(0.0, 0.433),\\n    vec2<f32>(-0.5, -0.433),\\n    vec2<f32>(0.5, -0.433),\\n  );\\n\\n  return vec4<f32>(triangle[index], 0.0, 1.0);\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderColoredTriangle(\\n  @builtin(position) pos_in: vec4<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return vec4<f32>(\\n    pos_in.x * 0.003,\\n    pos_in.y * 0.003,\\n    1.0 - (pos_in.y * 0.003),\\n    1.0,\\n  );\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport runDemo from \"./runDemo\"\n\nimport { Context, useProp, useGPUResource, useGPUUpdate } from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode from \"./demo1.wgsl\"\n\nrunDemo(RenderColoredTriangle)\n\nfunction RenderColoredTriangle(ctx: Context) {\n  const renderTarget = useProp<GPUTexture>(ctx)\n\n  const renderPipeline = useGPUResource(ctx, (ctx) => {\n    return ctx.device.createRenderPipeline({\n      layout: \"auto\",\n      primitive: { topology: \"triangle-list\" },\n      vertex: {\n        module: ctx.device.createShaderModule({ code: shaderModuleCode }),\n        entryPoint: \"vertexRenderColoredTriangle\",\n      },\n      fragment: {\n        module: ctx.device.createShaderModule({ code: shaderModuleCode }),\n        entryPoint: \"fragmentRenderColoredTriangle\",\n        targets: [\n          {\n            // TODO: Remove this hard-coded value - get the real one somehow.\n            format: \"rgba8unorm\" as GPUTextureFormat,\n          },\n        ],\n      },\n    })\n  })\n\n  useGPUUpdate([renderTarget], ctx, (ctx) => {\n    if (!renderTarget.current) return\n\n    const passEncoder = ctx.commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.current.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: \"clear\" as GPULoadOp,\n          storeOp: \"store\" as GPUStoreOp,\n        },\n      ],\n    })\n    passEncoder.setPipeline(renderPipeline.current)\n    passEncoder.draw(3, 1, 0, 0)\n    passEncoder.end()\n  })\n\n  return { renderTarget }\n}\n","import {\n  Context,\n  ContextForGPUResource,\n  ContextForGPUAction,\n  MaybeDestroyableGPUResource,\n  ContextEmpty,\n  ContextImplementation,\n} from \"./Context\"\nimport { Unit, UnitFn } from \"./Unit\"\nimport { Property, PropertyImplementation, PropertyReadOnly } from \"./Property\"\n\nexport function useProp<T>(ctx: Context): Property<T | undefined> {\n  return ctx._useProp<T | undefined>(undefined) as Property<T | undefined>\n}\n\nexport function useInitializedProp<T>(\n  ctx: Context,\n  initialValue: (() => T) | T,\n): Property<T> {\n  return ctx._useProp<T>(initialValue)\n}\n\nexport function useUnit<U>(ctx: Context, unitFn: UnitFn<U>): Unit<U> {\n  const unitProp = ctx._useProp<Unit<U>>(() => ({\n    ...unitFn(ctx),\n    _ctx: ctx as ContextImplementation,\n  }))\n\n  return (unitProp as PropertyImplementation<Unit<U>>)._current\n}\n\nexport function useGPUResource<T extends MaybeDestroyableGPUResource>(\n  ctx: Context,\n  create: (ctx: ContextForGPUResource) => T,\n): PropertyReadOnly<T> {\n  return ctx._useGPUResource<T>(create)\n}\n\nexport function useGPUUpdate(\n  producedProps: PropertyReadOnly<unknown>[],\n  ctx: Context,\n  action: (ctx: ContextForGPUAction) => void,\n): void {\n  ctx._useGPUUpdate(producedProps, action)\n}\n\nexport function useEffect(\n  ctx: Context,\n  effect: (ctx: ContextEmpty) => (() => void) | undefined,\n) {\n  return ctx._useEffect(effect)\n}\n","import { Context, ContextImplementation } from \"./Context\"\nimport { PropertyReadOnly } from \"./Property\"\n\nexport type Unit<U> = U & {\n  _ctx: ContextImplementation\n}\n\nexport type UnitRoot<U> = U & {\n  _ctx: ContextImplementation\n  runFrame: (\n    commandEncoder: GPUCommandEncoder,\n    outputs: PropertyReadOnly<unknown>[],\n  ) => void\n}\n\nexport type UnitFn<U> = (ctx: Context) => U\n\nexport function createUnitRoot<U>(\n  device: GPUDevice,\n  unitFn: UnitFn<U>,\n): UnitRoot<U> {\n  const ctx = new ContextImplementation(device)\n  const unitRoot = { ...unitFn(ctx), _ctx: ctx } as UnitRoot<U>\n  unitRoot.runFrame = (\n    commandEncoder: GPUCommandEncoder,\n    outputs: PropertyReadOnly<unknown>[],\n  ) => {\n    ctx._currentClockNumber += 1\n    ctx._commandEncoder = commandEncoder\n\n    const clockNumber = ctx._currentClockNumber\n    outputs.forEach((output) => output._produceIfNeededAt(clockNumber))\n\n    ctx._effects.forEach((effect) => effect._runIfNeededAt(clockNumber))\n\n    ctx._commandEncoder = undefined\n  }\n  return unitRoot\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","Symbol","toStringTag","Object","defineProperty","value","PropertyImplementation","constructor","initialValue","ctx","_changeAtNextTick","_changedClockNumber","_producedClockNumber","_producerOperations","_current","_next","_ctx","_attachProducerOperation","op","push","_runIfNeededAt","clockNumber","_produceIfNeededAt","forEach","current","currentAction","_currentAction","Error","_attachDependency","getNonReactively","readOnly","set","newValue","setAndNotify","notify","change","fn","mutate","DerivedImplementation","_deps","Set","_cachedClockNumber","_fn","dep","add","depsChanged","outerAction","previousResult","_cachedResult","destroy","currentDerived","_currentClockNumber","OperationImplementation","EffectImplementation","_lastClockNumber","lastCancelFn","_lastCancelFn","ContextImplementation","device","_effects","_device","commandEncoder","_commandEncoder","_useProp","_useGPUResource","_useGPUUpdate","producedProps","prop","_useEffect","OutputCanvas","canvasContext","_renders","_canvasContext","addRender","render","includes","outputFrame","target","getCurrentTexture","renderTarget","runFrame","getPreferredCanvasFormat","navigator","gpu","bind","renderFn","undefined","renderPipeline","create","createRenderPipeline","layout","primitive","topology","vertex","createShaderModule","code","entryPoint","fragment","targets","format","action","passEncoder","beginRenderPass","colorAttachments","view","createView","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","draw","end","setupFn","powerPreference","requestAdapter","requestDevice","getDevice","canvas","getContext","configure","alphaMode","compositingAlphaMode","getCanvasContext","document","querySelector","getDemoCanvas","frameFn","unitFn","unitRoot","outputs","output","effect","createUnitRoot","requestAnimationFrame","repeatFrameWithContext","createCommandEncoder","queue","submit","finish","runFrameWithContext","catch","error","innerHTML","console","runDemoInner"],"sourceRoot":""}