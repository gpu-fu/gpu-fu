{"version":3,"file":"demo1.js","mappings":"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","sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/webpack/runtime/make namespace object","webpack://beta/./src/runDemo.ts","webpack://beta/../incubator/src/OutputCanvas.ts","webpack://beta/../incubator/src/RenderUV.ts","webpack://beta/../incubator/src/RenderUV.wgsl","webpack://beta/../incubator/src/VertexSourceRect.ts","webpack://beta/../incubator/src/RenderTextureRect.ts","webpack://beta/../incubator/src/TextureFilterConvolve.ts","webpack://beta/../incubator/src/TextureFilterConvolve3x3.wgsl","webpack://beta/../incubator/src/TextureSourceBitmap.ts","webpack://beta/./src/demo1.wgsl","webpack://beta/./src/demo1.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference types=\"@webgpu/types\" />\n\nimport { Context } from \"@gpu-fu/gpu-fu\"\n\ntype FrameFn = (ctx: Context, frame: number) => void\ntype SetupFn = (\n  device: GPUDevice,\n  canvasContext: GPUCanvasContext,\n) => Promise<FrameFn>\n\nexport default function runDemo(setupFn: SetupFn) {\n  ;(async () => {\n    const device = await getDevice()\n    const canvasContext = await getCanvasContext(\"canvas.main\", device)\n\n    const frameFn = await setupFn(device, canvasContext)\n\n    var frame = 0\n    function repeatFrameWithContext() {\n      frame = frame + 1\n      runFrameWithContext(device, frame, frameFn)\n      requestAnimationFrame(repeatFrameWithContext)\n    }\n    requestAnimationFrame(repeatFrameWithContext)\n  })().catch((error) => {\n    document.querySelector(\"body\")!.innerHTML = error\n    console.error(error)\n  })\n}\n\nasync function getDevice(\n  powerPreference: GPUPowerPreference = \"high-performance\",\n): Promise<GPUDevice> {\n  if (!navigator.gpu)\n    throw new Error(\"Your browser doesn't have WebGPU enabled!\")\n\n  const gpu = await navigator.gpu.requestAdapter({ powerPreference })\n  if (!gpu) throw new Error(\"Failed to get the GPU adapter!\")\n\n  return gpu.requestDevice()\n}\n\nasync function getCanvasContext(\n  querySelector: string,\n  device: GPUDevice,\n): Promise<GPUCanvasContext> {\n  const canvas = document.querySelector(\n    querySelector,\n  ) as HTMLCanvasElement | null\n  if (!canvas) throw new Error(\"The main canvas wasn't found in the HTML!\")\n\n  const canvasContext = canvas.getContext(\"webgpu\") as GPUCanvasContext | null\n  if (!canvasContext) throw new Error(\"Failed to get a WebGPU canvas context!\")\n\n  canvasContext.configure({\n    device,\n    format: getPreferredCanvasFormat(),\n    alphaMode: \"opaque\",\n  })\n\n  return canvasContext\n}\n\nfunction getPreferredCanvasFormat() {\n  // Some browsers throw an \"Illegal invocation\" error if we don't bind.\n  const getPreferredCanvasFormat =\n    navigator.gpu?.getPreferredCanvasFormat?.bind(navigator.gpu)\n  if (getPreferredCanvasFormat) return getPreferredCanvasFormat()\n\n  // Hard-coded default for browsers that don't implement this function yet.\n  return \"rgba8unorm\"\n}\n\nfunction runFrameWithContext(\n  device: GPUDevice,\n  frame: number,\n  frameFn: FrameFn,\n) {\n  const commandEncoder = device.createCommandEncoder()\n  frameFn({ device, commandEncoder }, frame)\n  device.queue.submit([commandEncoder.finish()])\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, Render } from \"@gpu-fu/gpu-fu\"\n\nexport default class OutputCanvas {\n  _canvasContext: GPUCanvasContext\n  _renders: Render[] = []\n\n  constructor(canvasContext: GPUCanvasContext) {\n    this._canvasContext = canvasContext\n  }\n\n  addRender(render: Render) {\n    if (this._renders.includes(render)) return\n    this._renders.push(render)\n  }\n\n  outputFrame(ctx: Context, frame: number) {\n    const target = this._canvasContext.getCurrentTexture()\n    this._renders.forEach((render) => {\n      render.renderFrame(ctx, frame, target)\n    })\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  Context,\n  Render,\n  VertexSource,\n  TextureSource,\n  autoLayout,\n} from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode from \"./RenderUV.wgsl\"\n\nexport default class RenderUV implements Render {\n  private _vertexSource?: VertexSource\n  private _textureSource?: TextureSource\n\n  private _shaderModule?: GPUShaderModule\n  private _renderPipeline?: GPURenderPipeline\n  private _bindGroup?: GPUBindGroup\n\n  getVertexSource(): VertexSource {\n    if (this._vertexSource) return this._vertexSource\n    throw new Error(`${this} has no _vertexSource`)\n  }\n\n  setVertexSource(vertexSource: VertexSource) {\n    this._vertexSource = vertexSource\n    this._renderPipeline = undefined\n    this._bindGroup = undefined\n  }\n\n  getTextureSource(): TextureSource {\n    if (this._textureSource) return this._textureSource\n    throw new Error(`${this} has no _textureSource`)\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._textureSource = textureSource\n    this._renderPipeline = undefined\n    this._bindGroup = undefined\n  }\n\n  getShaderModule(ctx: Context): GPUShaderModule {\n    if (this._shaderModule) return this._shaderModule\n\n    return (this._shaderModule = ctx.device.createShaderModule({\n      code: shaderModuleCode,\n    }))\n  }\n\n  getRenderPipeline(ctx: Context): GPURenderPipeline {\n    if (this._renderPipeline) return this._renderPipeline\n\n    const vertexSource = this.getVertexSource()\n\n    return (this._renderPipeline = ctx.device.createRenderPipeline({\n      vertex: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"vertexRenderUV\",\n        buffers: [\n          {\n            arrayStride: vertexSource.vertexSourceStrideBytes(ctx),\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: vertexSource.vertexSourceXYZWOffsetBytes(ctx),\n                format: \"float32x4\" as GPUVertexFormat,\n              },\n              {\n                shaderLocation: 1,\n                offset: vertexSource.vertexSourceUVOffsetBytes(ctx),\n                format: \"float32x2\" as GPUVertexFormat,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"fragmentRenderUV\",\n        targets: [\n          {\n            // TODO: Remove this hard-coded value - get the real one somehow.\n            format: \"rgba8unorm\" as GPUTextureFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: \"triangle-list\",\n      },\n      layout: autoLayout(),\n    }))\n  }\n\n  getBindGroup(ctx: Context) {\n    if (this._bindGroup) return this._bindGroup\n\n    const sampler = ctx.device.createSampler({\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n    })\n\n    return (this._bindGroup = ctx.device.createBindGroup({\n      layout: this.getRenderPipeline(ctx).getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: sampler,\n        },\n        {\n          binding: 1,\n          resource: this.getTextureSource()\n            .textureSourceAsGPUTexture(ctx)\n            .createView(),\n        },\n      ],\n    }))\n  }\n\n  renderFrame(ctx: Context, frame: number, target: GPUTexture): void {\n    this.getTextureSource().textureSourceFrame(ctx, frame)\n    const vertexCount = this.getVertexSource().vertexSourceFrame(ctx, frame)\n\n    const passEncoder = ctx.commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: target.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: \"clear\" as GPULoadOp,\n          storeOp: \"store\" as GPUStoreOp,\n        },\n      ],\n    })\n    passEncoder.setPipeline(this.getRenderPipeline(ctx))\n    passEncoder.setVertexBuffer(\n      0,\n      this.getVertexSource().vertexSourceAsGPUBuffer(ctx),\n    )\n    passEncoder.setBindGroup(0, this.getBindGroup(ctx))\n    passEncoder.draw(vertexCount, 1, 0, 0)\n    passEncoder.end()\n  }\n}\n","export default \"@group(0) @binding(0) var use_sampler: sampler;\\n@group(0) @binding(1) var use_texture: texture_2d<f32>;\\n\\nstruct VertexOutput {\\n  @builtin(position) pos: vec4<f32>;\\n  @location(0) uv: vec2<f32>;\\n}\\n\\n@stage(vertex)\\nfn vertexRenderUV(\\n  @location(0) pos_in: vec4<f32>,\\n  @location(1) uv_in: vec2<f32>,\\n) ->\\n  VertexOutput\\n{\\n  var out: VertexOutput;\\n  out.pos = pos_in;\\n  out.uv = uv_in;\\n  return out;\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderUV(\\n  @location(0) uv_in : vec2<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return textureSample(use_texture, use_sampler, uv_in.xy);\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, VertexSource } from \"@gpu-fu/gpu-fu\"\n\nexport default class VertexSourceRect implements VertexSource {\n  private _aspectFillRatio?: number\n\n  private _buffer?: GPUBuffer\n  private _bufferUpToDate = false\n\n  setAspectFillRatio(ratio: number) {\n    if (this._aspectFillRatio === ratio) return\n    this._aspectFillRatio = ratio\n    this._bufferUpToDate = false\n  }\n\n  private getBuffer(ctx: Context): GPUBuffer {\n    if (this._buffer) return this._buffer\n\n    const buffer = ctx.device.createBuffer({\n      size: this.vertexSourceTotalBytes(ctx),\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    })\n\n    return (this._buffer = buffer)\n  }\n\n  private updateBuffer(ctx: Context) {\n    if (this._bufferUpToDate) return\n\n    var uMin = 0\n    var uMax = 1\n    var vMin = 0\n    var vMax = 1\n\n    if (this._aspectFillRatio) {\n      if (this._aspectFillRatio < 1) {\n        vMin = 0.5 - 0.5 * this._aspectFillRatio\n        vMax = 1 - vMin\n      } else {\n        uMin = 0.5 - 0.5 / this._aspectFillRatio\n        uMax = 1 - uMin\n      }\n    }\n\n    // prettier-ignore\n    const data = new Float32Array([\n    // (x, y, z, w),  (u, v)\n        1, 1, 0, 1, uMax, vMin,\n       -1,-1, 0, 1, uMin, vMax,\n       -1, 1, 0, 1, uMin, vMin,\n        1, 1, 0, 1, uMax, vMin,\n        1,-1, 0, 1, uMax, vMax,\n       -1,-1, 0, 1, uMin, vMax,\n    ])\n\n    ctx.device.queue.writeBuffer(this.getBuffer(ctx), 0, data, 0, data.length)\n\n    this._bufferUpToDate = true\n  }\n\n  vertexSourceAsGPUBuffer(ctx: Context): GPUBuffer {\n    return this.getBuffer(ctx)\n  }\n\n  vertexSourceTotalBytes = (ctx: Context) => 6 * 6 * 4\n  vertexSourceStrideBytes = (ctx: Context) => 6 * 4\n  vertexSourceXYZWOffsetBytes = (ctx: Context) => 0\n  vertexSourceUVOffsetBytes = (ctx: Context) => 4 * 4\n\n  vertexSourceFrame(ctx: Context, frame: number) {\n    this.updateBuffer(ctx)\n    return 6\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, Render, TextureSource } from \"@gpu-fu/gpu-fu\"\nimport RenderUV from \"./RenderUV\"\nimport VertexSourceRect from \"./VertexSourceRect\"\n\nexport default class RenderTextureRect implements Render {\n  private _renderUV = new RenderUV()\n\n  constructor() {\n    this._renderUV.setVertexSource(new VertexSourceRect())\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._renderUV.setTextureSource(textureSource)\n  }\n\n  renderFrame(ctx: Context, frame: number, target: GPUTexture): void {\n    // TODO : Use the source texture and target texture aspect ratios\n    // instead of hard-coding a number here.\n    // This doesn't yet work on the latest version of chromium, because\n    // those chromium builds don't yet expose texture width and height.\n    ;(this._renderUV.getVertexSource() as VertexSourceRect).setAspectFillRatio(\n      850 / 1275,\n    )\n    this._renderUV.renderFrame(ctx, frame, target)\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  Context,\n  TextureFilter,\n  TextureSource,\n  autoLayout,\n} from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode3x3 from \"./TextureFilterConvolve3x3.wgsl\"\n\ninterface SetKernelOptions {\n  bias?: number\n  scale?: number\n  normalize?: boolean\n}\n\nexport default class TextureFilterConvolve implements TextureFilter {\n  private _textureSource?: TextureSource\n  private _kernelData?: Float32Array\n\n  private _kernelBuffer?: GPUBuffer\n  private _kernelBufferUpToDate = false\n  private _texture?: GPUTexture\n  private _shaderModule?: GPUShaderModule\n  private _computePipeline?: GPUComputePipeline\n  private _bindGroup?: GPUBindGroup\n\n  private getKernelData(): Float32Array {\n    if (this._kernelData) return this._kernelData\n    throw new Error(`${this} has no _kernelData`)\n  }\n\n  setKernel3x3(\n    row0: [number, number, number],\n    row1: [number, number, number],\n    row2: [number, number, number],\n    opts: SetKernelOptions = {},\n  ) {\n    // Respect scale and/or normalize options if present.\n    if (opts.scale || opts.normalize) {\n      var scale = opts.scale ?? 1\n      if (opts.normalize) {\n        var sum = 0\n        sum = row0.reduce((accum, n) => accum + n, sum)\n        sum = row1.reduce((accum, n) => accum + n, sum)\n        sum = row2.reduce((accum, n) => accum + n, sum)\n        if (sum !== 0) scale = scale / sum\n      }\n      if (scale !== 1) {\n        row0 = row0.map((n) => n * scale) as typeof row0\n        row1 = row1.map((n) => n * scale) as typeof row1\n        row2 = row2.map((n) => n * scale) as typeof row2\n      }\n    }\n\n    // Create the kernel data array and fill it with data.\n    const kernelData = new Float32Array(10)\n    kernelData[0] = opts.bias ?? 0\n    kernelData.set(row0, 1)\n    kernelData.set(row1, 4)\n    kernelData.set(row2, 7)\n\n    // If the kernel size has changed, it invalidates almost everything.\n    if (kernelData.byteLength !== this._kernelData?.byteLength) {\n      this._kernelBuffer = undefined\n      this._shaderModule = undefined\n      this._computePipeline = undefined\n      this._bindGroup = undefined\n    }\n\n    // Assign the kernel data array and mark the buffer data as invalidated.\n    this._kernelData = kernelData\n    this._kernelBufferUpToDate = false\n  }\n\n  getTextureSource(): TextureSource {\n    if (this._textureSource) return this._textureSource\n    throw new Error(`${this} has no _textureSource`)\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._textureSource = textureSource\n    this._bindGroup = undefined\n  }\n\n  private getKernelBuffer(ctx: Context): GPUBuffer {\n    if (this._kernelBuffer) return this._kernelBuffer\n\n    console.log(\"byteLength\", this.getKernelData().byteLength)\n\n    const buffer = ctx.device.createBuffer({\n      size: this.getKernelData().byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    })\n\n    return (this._kernelBuffer = buffer)\n  }\n\n  private updateKernelBuffer(ctx: Context) {\n    if (this._kernelBufferUpToDate) return\n\n    const data = this.getKernelData()\n\n    ctx.device.queue.writeBuffer(\n      this.getKernelBuffer(ctx),\n      0,\n      data,\n      0,\n      data.length,\n    )\n\n    this._kernelBufferUpToDate = true\n  }\n\n  private getShaderModule(ctx: Context): GPUShaderModule {\n    if (this._shaderModule) return this._shaderModule\n\n    let shaderModuleCode: string\n    switch (this.getKernelData().length) {\n      case 10:\n        shaderModuleCode = shaderModuleCode3x3\n        break\n      default:\n        throw new Error(\"_kernelData length is invalid!\")\n    }\n\n    return (this._shaderModule = ctx.device.createShaderModule({\n      code: shaderModuleCode,\n    }))\n  }\n\n  private getComputePipeline(ctx: Context): GPUComputePipeline {\n    if (this._computePipeline) return this._computePipeline\n\n    return (this._computePipeline = ctx.device.createComputePipeline({\n      compute: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"computeTextureFilterConvolve3x3\",\n      },\n      layout: autoLayout(),\n    }))\n  }\n\n  private getBindGroup(ctx: Context) {\n    if (this._bindGroup) return this._bindGroup\n\n    const sampler = ctx.device.createSampler({\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n    })\n\n    return (this._bindGroup = ctx.device.createBindGroup({\n      layout: this.getComputePipeline(ctx).getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: this.getKernelBuffer(ctx) },\n        },\n        {\n          binding: 1,\n          resource: this.getTextureSource()\n            .textureSourceAsGPUTexture(ctx)\n            .createView(),\n        },\n        {\n          binding: 2,\n          resource: this.textureSourceAsGPUTexture(ctx).createView(),\n        },\n      ],\n    }))\n  }\n\n  textureSourceAsGPUTexture(ctx: Context): GPUTexture {\n    if (this._texture) return this._texture\n\n    const textureSource = this.getTextureSource().textureSourceAsGPUTexture(ctx)\n\n    this._texture = ctx.device.createTexture({\n      format: \"rgba8unorm\",\n      size: {\n        width: textureSource.width || 850, // TODO: remove fallback value\n        height: textureSource.height || 1275, // TODO: remove fallback value\n      },\n      usage:\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.STORAGE_BINDING |\n        GPUTextureUsage.TEXTURE_BINDING,\n    })\n\n    return this._texture\n  }\n\n  textureSourceFrame(ctx: Context, frame: number) {\n    this.updateKernelBuffer(ctx)\n\n    const textureSource = this.getTextureSource().textureSourceAsGPUTexture(ctx)\n    const workGroupSizeX = 32 // (must match the WGSL code)\n    const workGroupSizeY = 1 // (must match the WGSL code)\n\n    const passEncoder = ctx.commandEncoder.beginComputePass()\n    passEncoder.setPipeline(this.getComputePipeline(ctx))\n    passEncoder.setBindGroup(0, this.getBindGroup(ctx))\n    passEncoder.dispatch(\n      (textureSource.width || 850) / workGroupSizeX, // TODO: remove fallback value\n      (textureSource.height || 1275) / workGroupSizeY, // TODO: remove fallback value\n    )\n    passEncoder.end()\n  }\n}\n","export default \"@group(0) @binding(0) var<uniform> kernel_3x3: Kernel3x3;\\n@group(0) @binding(1) var texture_in: texture_2d<f32>;\\n@group(0) @binding(2) var texture_out: texture_storage_2d<rgba8unorm, write>;\\n\\nstruct Kernel3x3 {\\n  bias: f32;\\n  aa: f32;\\n  ba: f32;\\n  ca: f32;\\n  ab: f32;\\n  bb: f32;\\n  cb: f32;\\n  ac: f32;\\n  bc: f32;\\n  cc: f32;\\n}\\n\\n// TODO: What is the most likely optimal workgroup size?\\n@stage(compute) @workgroup_size(32, 1, 1)\\nfn computeTextureFilterConvolve3x3(\\n  @builtin(global_invocation_id) global_id: vec3<u32>,\\n) {\\n  let b = vec2<i32>(global_id.xy);\\n  let a = max(b - 1, vec2<i32>(0));\\n  let c = min(b + 1, min(\\n    textureDimensions(texture_in),\\n    textureDimensions(texture_out),\\n  ));\\n\\n  var sum = vec4<f32>(kernel_3x3.bias);\\n\\n  sum = sum + kernel_3x3.aa * textureLoad(texture_in, vec2<i32>(a.x, a.y), 0);\\n  sum = sum + kernel_3x3.ba * textureLoad(texture_in, vec2<i32>(b.x, a.y), 0);\\n  sum = sum + kernel_3x3.ca * textureLoad(texture_in, vec2<i32>(c.x, a.y), 0);\\n\\n  sum = sum + kernel_3x3.ab * textureLoad(texture_in, vec2<i32>(a.x, b.y), 0);\\n  sum = sum + kernel_3x3.bb * textureLoad(texture_in, vec2<i32>(b.x, b.y), 0);\\n  sum = sum + kernel_3x3.cb * textureLoad(texture_in, vec2<i32>(c.x, b.y), 0);\\n\\n  sum = sum + kernel_3x3.ac * textureLoad(texture_in, vec2<i32>(a.x, c.y), 0);\\n  sum = sum + kernel_3x3.bc * textureLoad(texture_in, vec2<i32>(b.x, c.y), 0);\\n  sum = sum + kernel_3x3.cc * textureLoad(texture_in, vec2<i32>(c.x, c.y), 0);\\n\\n  textureStore(texture_out, b, sum);\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, TextureSource } from \"@gpu-fu/gpu-fu\"\n\nexport default class TextureSourceBitmap implements TextureSource {\n  private _imageBitmap: ImageBitmap\n  private _label: string\n\n  private _texture?: GPUTexture\n\n  constructor(imageBitmap: ImageBitmap, label: string) {\n    this._imageBitmap = imageBitmap\n    this._label = label\n  }\n\n  static async fromURL(url: string, label?: string) {\n    const img = document.createElement(\"img\")\n    img.src = url\n    await img.decode()\n    const imageBitmap = await createImageBitmap(img)\n    return new TextureSourceBitmap(imageBitmap, label ?? url)\n  }\n\n  textureSourceAsGPUTexture(ctx: Context): GPUTexture {\n    if (this._texture) return this._texture\n\n    this._texture = ctx.device.createTexture({\n      label: this._label,\n      size: [this._imageBitmap.width, this._imageBitmap.height, 1],\n      format: \"rgba8unorm\",\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    })\n\n    ctx.device.queue.copyExternalImageToTexture(\n      { source: this._imageBitmap },\n      { texture: this._texture },\n      [this._imageBitmap.width, this._imageBitmap.height],\n    )\n\n    console.log(this._texture)\n\n    return this._texture\n  }\n\n  textureSourceFrame(ctx: Context, frame: number): void {}\n}\n","export default \"@stage(vertex)\\nfn vertexRenderColoredTriangle(\\n  @builtin(vertex_index) index: u32\\n) ->\\n  @builtin(position) vec4<f32>\\n{\\n  let triangle = array<vec2<f32>, 3>(\\n    vec2<f32>(0.0, 0.433),\\n    vec2<f32>(-0.5, -0.433),\\n    vec2<f32>(0.5, -0.433),\\n  );\\n\\n  return vec4<f32>(triangle[index], 0.0, 1.0);\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderColoredTriangle(\\n  @builtin(position) pos_in: vec4<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return vec4<f32>(\\n    pos_in.x * 0.003,\\n    pos_in.y * 0.003,\\n    1.0 - (pos_in.y * 0.003),\\n    1.0,\\n  );\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport runDemo from \"./runDemo\"\n\nimport { Context, Render, autoLayout } from \"@gpu-fu/gpu-fu\"\nimport { OutputCanvas } from \"@gpu-fu/incubator\"\n\nimport shaderModuleCode from \"./demo1.wgsl\"\n\nrunDemo(async (device, canvasContext) => {\n  const renderTriangle = new RenderColoredTriangle()\n\n  const output = new OutputCanvas(canvasContext)\n  output.addRender(renderTriangle)\n\n  return function frame(ctx, frame) {\n    output.outputFrame(ctx, frame)\n  }\n})\n\nclass RenderColoredTriangle implements Render {\n  _renderPipeline?: GPURenderPipeline\n\n  getRenderPipeline(ctx: Context) {\n    if (this._renderPipeline) return this._renderPipeline\n\n    return (this._renderPipeline = ctx.device.createRenderPipeline({\n      vertex: {\n        module: ctx.device.createShaderModule({ code: shaderModuleCode }),\n        entryPoint: \"vertexRenderColoredTriangle\",\n      },\n      fragment: {\n        module: ctx.device.createShaderModule({ code: shaderModuleCode }),\n        entryPoint: \"fragmentRenderColoredTriangle\",\n        targets: [\n          {\n            // TODO: Remove this hard-coded value - get the real one somehow.\n            format: \"rgba8unorm\" as GPUTextureFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: \"triangle-list\",\n      },\n      layout: autoLayout(),\n    }))\n  }\n\n  renderFrame(ctx: Context, frame: number, target: GPUTexture): void {\n    const passEncoder = ctx.commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: target.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: \"clear\" as GPULoadOp,\n          storeOp: \"store\" as GPUStoreOp,\n        },\n      ],\n    })\n    passEncoder.setPipeline(this.getRenderPipeline(ctx))\n    passEncoder.draw(3, 1, 0, 0)\n    passEncoder.end()\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","Symbol","toStringTag","Object","defineProperty","value","getDevice","powerPreference","navigator","gpu","Error","requestAdapter","requestDevice","getCanvasContext","querySelector","device","canvas","document","canvasContext","getContext","configure","format","getPreferredCanvasFormat","alphaMode","bind","_renders","_canvasContext","addRender","render","includes","push","outputFrame","ctx","frame","target","getCurrentTexture","forEach","renderFrame","getVertexSource","_vertexSource","setVertexSource","vertexSource","_renderPipeline","undefined","_bindGroup","getTextureSource","_textureSource","setTextureSource","textureSource","getShaderModule","_shaderModule","createShaderModule","code","getRenderPipeline","createRenderPipeline","vertex","entryPoint","buffers","arrayStride","vertexSourceStrideBytes","attributes","shaderLocation","offset","vertexSourceXYZWOffsetBytes","vertexSourceUVOffsetBytes","fragment","targets","primitive","topology","layout","autoLayout","getBindGroup","sampler","createSampler","magFilter","minFilter","createBindGroup","getBindGroupLayout","entries","binding","resource","textureSourceAsGPUTexture","createView","textureSourceFrame","vertexCount","vertexSourceFrame","passEncoder","commandEncoder","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","setVertexBuffer","vertexSourceAsGPUBuffer","setBindGroup","draw","end","_bufferUpToDate","vertexSourceTotalBytes","setAspectFillRatio","ratio","_aspectFillRatio","getBuffer","_buffer","buffer","createBuffer","size","usage","GPUBufferUsage","VERTEX","COPY_DST","updateBuffer","uMin","uMax","vMin","vMax","data","Float32Array","queue","writeBuffer","length","_renderUV","_kernelBufferUpToDate","getKernelData","_kernelData","setKernel3x3","row0","row1","row2","opts","scale","normalize","sum","reduce","accum","n","map","kernelData","bias","set","byteLength","_kernelBuffer","_computePipeline","getKernelBuffer","console","log","UNIFORM","updateKernelBuffer","getComputePipeline","createComputePipeline","compute","_texture","createTexture","width","height","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","beginComputePass","dispatch","imageBitmap","label","_imageBitmap","_label","fromURL","url","img","createElement","src","decode","createImageBitmap","TextureSourceBitmap","RENDER_ATTACHMENT","copyExternalImageToTexture","source","texture","setupFn","repeatFrameWithContext","frameFn","createCommandEncoder","submit","finish","runFrameWithContext","requestAnimationFrame","error","innerHTML","runDemo","renderTriangle","RenderColoredTriangle","output"],"sourceRoot":""}