{"version":3,"file":"demo1.js","mappings":"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","sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/webpack/runtime/make namespace object","webpack://beta/../gpu-fu/src/Context.ts","webpack://beta/../incubator/src/OutputCanvas.ts","webpack://beta/./src/runDemo.ts","webpack://beta/./src/demo1.wgsl","webpack://beta/./src/demo1.ts","webpack://beta/../gpu-fu/src/hooks.ts","webpack://beta/../gpu-fu/src/Unit.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference types=\"@webgpu/types\" />\n\nimport { Unit } from \"./Unit\"\nimport { Property } from \"./Property\"\n\nexport type MaybeDestroyableGPUResource =\n  | undefined\n  | 0\n  | false\n  | null\n  | (GPUObjectBase & { destroy?: () => void })\nexport type StoreItemGPUResource<T extends MaybeDestroyableGPUResource> = [\n  T,\n  unknown[],\n]\n\nexport type StoreItemGPUAction = [\n  (ctx: ContextForGPUAction) => void,\n  unknown[],\n  boolean,\n]\n\nexport type StoreItemEffect = [(() => void) | undefined, unknown[]]\n\nexport class ContextImplementation<U> {\n  private _unitFn: (ctx: Context) => U\n\n  device: GPUDevice\n  commandEncoder?: GPUCommandEncoder\n\n  constructor(unitFn: (ctx: Context) => U, device: GPUDevice) {\n    this._unitFn = unitFn\n    this.device = device\n  }\n\n  ///\n  // This next section relates to private storage of state and effects.\n\n  private _store: unknown[] = []\n  private _storeIndex = 0\n  private _storeUnits: Property<Unit<unknown> | undefined>[] = []\n  private _storeUnitsIndex = 0\n  private _storeGPUActions: StoreItemGPUAction[] = []\n  private _storeGPUActionsIndex = 0\n  private _needsUnitReRun = true\n\n  private _nextStoreIndex() {\n    const storeIndex = this._storeIndex\n    this._storeIndex = storeIndex + 1\n    return storeIndex\n  }\n\n  private _nextStoreUnitsIndex() {\n    const storeUnitsIndex = this._storeUnitsIndex\n    this._storeUnitsIndex = storeUnitsIndex + 1\n    return storeUnitsIndex\n  }\n\n  private _nextStoreGPUActionsIndex() {\n    const storeGPUActionsIndex = this._storeGPUActionsIndex\n    this._storeGPUActionsIndex = storeGPUActionsIndex + 1\n    return storeGPUActionsIndex\n  }\n\n  ///\n  // This next section has public methods related to running the unit.\n\n  runUnitIfNeeded(currentUnit: U) {\n    var otherUnitsRan = false\n    this._storeUnits.forEach((unitProp) => {\n      const unit = unitProp()\n      const otherUnitRan = unit?._ctx.runUnitIfNeeded(unit)\n      if (otherUnitRan) otherUnitsRan = true\n    })\n\n    if (this._needsUnitReRun || otherUnitsRan) {\n      this._storeIndex = 0\n      this._storeUnitsIndex = 0\n      this._storeGPUActionsIndex = 0\n      this._needsUnitReRun = false\n      Object.assign(currentUnit, this._unitFn(this))\n      return true\n    } else {\n      return false\n    }\n  }\n\n  runGPUActionsIfNeeded(commandEncoder: GPUCommandEncoder) {\n    this._storeUnits.forEach((unitProp) => {\n      const unit = unitProp()\n      unit?._ctx.runGPUActionsIfNeeded(commandEncoder)\n    })\n\n    this.commandEncoder = commandEncoder\n    this._storeGPUActions.forEach(([action, deps, needsRun], index) => {\n      if (needsRun) {\n        action(this as ContextForGPUAction)\n        this._storeGPUActions[index][2] = false\n      }\n    })\n    this.commandEncoder = undefined\n  }\n\n  ///\n  // This next section has public methods\n\n  _useProp<T>(initialValue: (() => T) | T): Property<T> {\n    const storeIndex = this._nextStoreIndex()\n    const existing = this._store[storeIndex] as Property<T>\n\n    // If there is an existing property pair, return it now.\n    if (existing) return existing\n\n    // Otherwise create, store, and return a new prop/setProp pair,\n    // using the provided initial state value or function.\n    const ctx = this\n\n    var value: T =\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue\n\n    // TODO: Subscription tracking\n    const prop: Property<T> = (() => value) as Property<T>\n    prop.set = (newValue: T) => {\n      if (value !== newValue) {\n        value = newValue\n        ctx._needsUnitReRun = true\n      }\n    }\n    prop.change = (fn: (currentValue: T) => T) => {\n      const newValue = fn(value)\n      if (value !== newValue) {\n        value = newValue\n        ctx._needsUnitReRun = true\n      }\n    }\n    prop.mutate = (fn: (currentValue: T) => void) => {\n      fn(value)\n      ctx._needsUnitReRun = true // assume mutation always happens\n    }\n\n    this._store[storeIndex] = prop\n    return prop\n  }\n\n  _useUnitProp<T extends Unit<unknown> | undefined>(\n    initialValue: (() => T) | T,\n  ): Property<T> {\n    const storeIndex = this._nextStoreUnitsIndex()\n    const existing = this._storeUnits[storeIndex] as Property<T>\n\n    // If there is an existing prop/setProp pair, return it now.\n    if (existing) return existing\n\n    // Otherwise create, store, and return a new prop/setProp pair,\n    // using the provided initial state value or function.\n    const ctx = this\n\n    var value: T =\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue\n\n    // TODO: Subscription tracking\n    const prop: Property<T> = (() => value) as Property<T>\n    prop.set = (newValue: T) => {\n      if (value !== newValue) {\n        value = newValue\n        ctx._needsUnitReRun = true\n      }\n    }\n    prop.change = (fn: (currentValue: T) => T) => {\n      const newValue = fn(value)\n      if (value !== newValue) {\n        value = newValue\n        ctx._needsUnitReRun = true\n      }\n    }\n    prop.mutate = (fn: (currentValue: T) => void) => {\n      fn(value)\n      ctx._needsUnitReRun = true // assume mutation always happens\n    }\n\n    this._storeUnits[storeIndex] = prop\n    return prop\n  }\n\n  _useGPUResource<T extends MaybeDestroyableGPUResource>(\n    create: (ctx: ContextForGPUResource) => T,\n    deps: Array<unknown>,\n  ): T {\n    const storeIndex = this._nextStoreIndex()\n    const existing = this._store[storeIndex] as StoreItemGPUResource<T>\n\n    // If the resource has never been created, create it now.\n    if (!existing) {\n      const newResource = create(this)\n      this._store[storeIndex] = [newResource, deps]\n      return newResource\n    }\n\n    // If the resource exists, and all new dependencies have the same identity\n    // as the corresponding old dependencies, return the existing resource.\n    if (deps.every((dep, index) => dep === existing[1][index]))\n      return existing[0]\n\n    // Create the new resource and store it along with its dependencies.\n    const newResource = create(this)\n    const oldResource = existing[0]\n    existing[0] = newResource\n    existing[1] = deps\n\n    // Destroy the old resource if applicable.\n    if (oldResource && typeof oldResource.destroy === \"function\")\n      oldResource.destroy()\n\n    // Return the new resource\n    return newResource\n  }\n\n  _useGPUAction(\n    action: (ctx: ContextForGPUAction) => void,\n    deps: Array<unknown>,\n  ): void {\n    const storeIndex = this._nextStoreGPUActionsIndex()\n    const existing = this._storeGPUActions[storeIndex] as StoreItemGPUAction\n\n    // If the action has never been stored, store it now and return early.\n    if (!existing) {\n      this._storeGPUActions[storeIndex] = [action, deps, true]\n      return\n    }\n\n    // If the action is known, and all new dependencies have the same identity\n    // as the corresponding old dependencies, return without doing anything.\n    if (deps.every((dep, index) => dep === existing[1][index])) return\n\n    // Update the action function along with its dependencies,\n    // and mark it as being \"dirty\" (i.e. in need of being executed again).\n    existing[0] = action\n    existing[1] = deps\n    existing[2] = true\n    return\n  }\n\n  _useEffect(\n    effect: (ctx: ContextEmpty) => (() => void) | undefined,\n    deps: Array<unknown>,\n  ) {\n    const storeIndex = this._nextStoreIndex()\n    const existing = this._store[storeIndex] as StoreItemEffect\n\n    // If the effect has never been stored, store it now after executing.\n    if (!existing) {\n      const cancelFn = effect({})\n      this._store[storeIndex] = [cancelFn, deps]\n      return\n    }\n\n    // If the effect is known, and all new dependencies have the same identity\n    // as the corresponding old dependencies, return without doing anything.\n    if (deps.every((dep, index) => dep === existing[1][index])) return\n\n    // Call the existing cancel function if there is one.\n    if (existing[0]) existing[0]()\n\n    // Execute the effect function to get the new cancel function, then\n    // store it along with the new dependency identities.\n    existing[0] = effect({})\n    existing[1] = deps\n    return\n  }\n}\n\nexport type Context = Pick<\n  ContextImplementation<unknown>,\n  // In the main function context, hooks are available.\n  | \"device\"\n  | \"_useProp\"\n  | \"_useUnitProp\"\n  | \"_useGPUResource\"\n  | \"_useGPUAction\"\n  | \"_useEffect\"\n>\n\nexport type ContextForGPUResource = Pick<\n  ContextImplementation<unknown>,\n  // No hooks are available.\n  \"device\"\n>\n\nexport type ContextForGPUAction = Pick<\n  ContextImplementation<unknown>,\n  // No hooks are available, but a command encoder is available.\n  \"device\"\n> & { commandEncoder: GPUCommandEncoder }\n\nexport type ContextEmpty = {}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Render, UnitRoot } from \"@gpu-fu/gpu-fu\"\n\nexport default class OutputCanvas {\n  _canvasContext: GPUCanvasContext\n  _renders: UnitRoot<Render>[] = []\n\n  constructor(canvasContext: GPUCanvasContext) {\n    this._canvasContext = canvasContext\n  }\n\n  addRender(render: UnitRoot<Render>) {\n    if (this._renders.includes(render)) return\n    this._renders.push(render)\n  }\n\n  outputFrame(commandEncoder: GPUCommandEncoder) {\n    const target = this._canvasContext.getCurrentTexture()\n    this._renders.forEach((render) => {\n      render.renderTarget.set(target)\n      render.runFrame(commandEncoder)\n    })\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { UnitFn, createUnitRoot, Render } from \"@gpu-fu/gpu-fu\"\nimport { OutputCanvas } from \"@gpu-fu/incubator\"\n\ntype FrameFn = (commandEncoder: GPUCommandEncoder) => void\ntype SetupFn = (device: GPUDevice, canvasContext: GPUCanvasContext) => FrameFn\n\nexport default function runDemo(renderFn: UnitFn<Render>) {\n  runDemoInner((device, canvasContext) => {\n    const render = createUnitRoot(device, renderFn)\n\n    const output = new OutputCanvas(canvasContext)\n    output.addRender(render)\n\n    return function frame(commandEncoder) {\n      output.outputFrame(commandEncoder)\n    }\n  })\n}\n\nfunction runDemoInner(setupFn: SetupFn) {\n  ;(async () => {\n    const device = await getDevice()\n    const canvasContext = await getCanvasContext(getDemoCanvas(), device)\n\n    const frameFn = setupFn(device, canvasContext)\n\n    function repeatFrameWithContext() {\n      runFrameWithContext(device, frameFn)\n      requestAnimationFrame(repeatFrameWithContext)\n    }\n    requestAnimationFrame(repeatFrameWithContext)\n  })().catch((error) => {\n    document.querySelector(\"body\")!.innerHTML = error\n    console.error(error)\n  })\n}\n\nasync function getDevice(\n  powerPreference: GPUPowerPreference = \"high-performance\",\n): Promise<GPUDevice> {\n  if (!navigator.gpu)\n    throw new Error(\"Your browser doesn't have WebGPU enabled!\")\n\n  const gpu = await navigator.gpu.requestAdapter({ powerPreference })\n  if (!gpu) throw new Error(\"Failed to get the GPU adapter!\")\n\n  return gpu.requestDevice()\n}\n\nexport function getDemoCanvas(): HTMLCanvasElement {\n  const canvas = document.querySelector(\n    \"canvas.main\",\n  ) as HTMLCanvasElement | null\n  if (!canvas) throw new Error(\"The main canvas wasn't found in the HTML!\")\n\n  return canvas\n}\n\nasync function getCanvasContext(\n  canvas: HTMLCanvasElement,\n  device: GPUDevice,\n): Promise<GPUCanvasContext> {\n  const canvasContext = canvas.getContext(\"webgpu\") as GPUCanvasContext | null\n  if (!canvasContext) throw new Error(\"Failed to get a WebGPU canvas context!\")\n\n  canvasContext.configure({\n    device,\n    format: getPreferredCanvasFormat(),\n    alphaMode: \"opaque\",\n  })\n\n  return canvasContext\n}\n\nfunction getPreferredCanvasFormat() {\n  // Some browsers throw an \"Illegal invocation\" error if we don't bind.\n  const getPreferredCanvasFormat =\n    navigator.gpu?.getPreferredCanvasFormat?.bind(navigator.gpu)\n  if (getPreferredCanvasFormat) return getPreferredCanvasFormat()\n\n  // Hard-coded default for browsers that don't implement this function yet.\n  return \"rgba8unorm\"\n}\n\nfunction runFrameWithContext(device: GPUDevice, frameFn: FrameFn) {\n  const commandEncoder = device.createCommandEncoder()\n  frameFn(commandEncoder)\n  device.queue.submit([commandEncoder.finish()])\n}\n","export default \"@stage(vertex)\\nfn vertexRenderColoredTriangle(\\n  @builtin(vertex_index) index: u32\\n) ->\\n  @builtin(position) vec4<f32>\\n{\\n  let triangle = array<vec2<f32>, 3>(\\n    vec2<f32>(0.0, 0.433),\\n    vec2<f32>(-0.5, -0.433),\\n    vec2<f32>(0.5, -0.433),\\n  );\\n\\n  return vec4<f32>(triangle[index], 0.0, 1.0);\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderColoredTriangle(\\n  @builtin(position) pos_in: vec4<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return vec4<f32>(\\n    pos_in.x * 0.003,\\n    pos_in.y * 0.003,\\n    1.0 - (pos_in.y * 0.003),\\n    1.0,\\n  );\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport runDemo from \"./runDemo\"\n\nimport {\n  Context,\n  autoLayout,\n  useProp,\n  useGPUResource,\n  useGPUAction,\n} from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode from \"./demo1.wgsl\"\n\nrunDemo(RenderColoredTriangle)\n\nfunction RenderColoredTriangle(ctx: Context) {\n  const renderTarget = useProp<GPUTexture>(ctx)\n\n  const renderPipeline = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createRenderPipeline({\n        vertex: {\n          module: ctx.device.createShaderModule({ code: shaderModuleCode }),\n          entryPoint: \"vertexRenderColoredTriangle\",\n        },\n        fragment: {\n          module: ctx.device.createShaderModule({ code: shaderModuleCode }),\n          entryPoint: \"fragmentRenderColoredTriangle\",\n          targets: [\n            {\n              // TODO: Remove this hard-coded value - get the real one somehow.\n              format: \"rgba8unorm\" as GPUTextureFormat,\n            },\n          ],\n        },\n        primitive: {\n          topology: \"triangle-list\",\n        },\n        layout: autoLayout(),\n      }),\n    [],\n  )\n\n  useGPUAction(\n    ctx,\n    (ctx) => {\n      const currentRenderTarget = renderTarget()\n      if (!currentRenderTarget) return\n\n      const passEncoder = ctx.commandEncoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: currentRenderTarget.createView(),\n            clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n            loadOp: \"clear\" as GPULoadOp,\n            storeOp: \"store\" as GPUStoreOp,\n          },\n        ],\n      })\n      passEncoder.setPipeline(renderPipeline)\n      passEncoder.draw(3, 1, 0, 0)\n      passEncoder.end()\n    },\n    [renderTarget()],\n  )\n\n  return { renderTarget }\n}\n","import {\n  Context,\n  ContextForGPUResource,\n  ContextForGPUAction,\n  MaybeDestroyableGPUResource,\n  ContextEmpty,\n} from \"./Context\"\nimport { Unit, UnitFn, NotAUnit, unit } from \"./Unit\"\nimport { Property } from \"./Property\"\n\nexport function useProp<T>(ctx: Context): Property<NotAUnit<T | undefined>> {\n  return ctx._useProp<T | undefined>(undefined) as Property<\n    NotAUnit<T | undefined>\n  >\n}\n\nexport function useInitializedProp<T>(\n  ctx: Context,\n  initialValue: (() => NotAUnit<T>) | NotAUnit<T>,\n): Property<NotAUnit<T>> {\n  return ctx._useProp<NotAUnit<T>>(initialValue)\n}\n\nexport function useUnitProp<U>(ctx: Context): Property<Unit<U> | undefined> {\n  return ctx._useUnitProp<Unit<U> | undefined>(undefined)\n}\n\nexport function useUnit<U>(ctx: Context, unitFn: UnitFn<U>): Unit<U> {\n  return ctx._useUnitProp<Unit<U>>(() => unit(ctx.device, unitFn))()\n}\n\nexport function useGPUResource<T extends MaybeDestroyableGPUResource>(\n  ctx: Context,\n  create: (ctx: ContextForGPUResource) => T,\n  deps: Array<unknown>,\n): T {\n  return ctx._useGPUResource<T>(create, deps)\n}\n\nexport function useGPUAction(\n  ctx: Context,\n  action: (ctx: ContextForGPUAction) => void,\n  deps: Array<unknown>,\n): void {\n  ctx._useGPUAction(action, deps)\n}\n\nexport function useEffect<T>(\n  ctx: Context,\n  effect: (ctx: ContextEmpty) => (() => void) | undefined,\n  deps: Array<unknown>,\n) {\n  return ctx._useEffect(effect, deps)\n}\n\nexport function useAsyncPropSetter<T>(\n  ctx: Context,\n  setPropFn: (newValue: T) => unknown,\n  effect: (ctx: ContextEmpty) => Promise<T>,\n  deps: Array<unknown>,\n) {\n  return ctx._useEffect((ctx) => {\n    var cancelled = false\n    effect(ctx)\n      .then((value) => cancelled || setPropFn(value))\n      .catch((error) => {\n        console.error(error)\n        cancelled = true\n      })\n    return () => {\n      cancelled = true\n    }\n  }, deps)\n}\n","import { Context, ContextImplementation } from \"./Context\"\n\nexport type UnitAny = {\n  _ctx: Context\n}\n\nexport type Unit<U> = U & {\n  _ctx: ContextImplementation<U>\n}\n\nexport type UnitRoot<U> = U & {\n  _ctx: ContextImplementation<U>\n  runFrame: (commandEncoder: GPUCommandEncoder) => void\n}\n\nexport type UnitFn<U> = (ctx: Context) => U\n\nexport type NotAUnit<T> = T extends UnitAny ? never : T\n\nexport function unit<U>(\n  device: GPUDevice,\n  unitFn: (ctx: Context) => U,\n): Unit<U> {\n  const ctx = new ContextImplementation<U>(unitFn, device)\n  return { ...unitFn(ctx), _ctx: ctx }\n}\n\nfunction unitFrame<U>(unit: Unit<U>, commandEncoder: GPUCommandEncoder) {\n  const ctx = unit._ctx\n  ctx.runUnitIfNeeded(unit)\n  ctx.runGPUActionsIfNeeded(commandEncoder)\n}\n\nexport function createUnitRoot<U>(\n  device: GPUDevice,\n  unitFn: (ctx: Context) => U,\n): UnitRoot<U> {\n  const ctx = new ContextImplementation<U>(unitFn, device)\n  const unitRoot = { ...unitFn(ctx), _ctx: ctx } as UnitRoot<U>\n  unitRoot.runFrame = (commandEncoder: GPUCommandEncoder) =>\n    unitFrame(unitRoot, commandEncoder)\n  return unitRoot\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","Symbol","toStringTag","Object","defineProperty","value","unitFn","device","_store","_storeIndex","_storeUnits","_storeUnitsIndex","_storeGPUActions","_storeGPUActionsIndex","_needsUnitReRun","_unitFn","_nextStoreIndex","storeIndex","_nextStoreUnitsIndex","storeUnitsIndex","_nextStoreGPUActionsIndex","storeGPUActionsIndex","runUnitIfNeeded","currentUnit","otherUnitsRan","forEach","unitProp","unit","_ctx","assign","runGPUActionsIfNeeded","commandEncoder","index","action","undefined","_useProp","initialValue","existing","ctx","prop","set","newValue","change","fn","mutate","_useUnitProp","_useGPUResource","create","deps","every","dep","newResource","oldResource","destroy","_useGPUAction","_useEffect","effect","cancelFn","canvasContext","_renders","_canvasContext","addRender","render","includes","push","outputFrame","target","getCurrentTexture","renderTarget","runFrame","getDevice","powerPreference","navigator","gpu","Error","requestAdapter","requestDevice","getDemoCanvas","canvas","document","querySelector","getCanvasContext","getContext","configure","format","getPreferredCanvasFormat","alphaMode","bind","renderFn","renderPipeline","createRenderPipeline","vertex","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","layout","currentRenderTarget","passEncoder","beginRenderPass","colorAttachments","view","createView","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","draw","end","setupFn","repeatFrameWithContext","frameFn","createCommandEncoder","queue","submit","finish","runFrameWithContext","requestAnimationFrame","unitRoot","unitFrame","createUnitRoot","output","error","innerHTML","console","runDemoInner"],"sourceRoot":""}