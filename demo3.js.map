{"version":3,"file":"demo3.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAc,KAAID,IAElBD,EAAW,KAAIC,IARjB,CASmB,oBAATK,KAAuBA,KAAOC,MAAM,I,mBCR9C,I,KCAwB,CAACL,IACH,oBAAXM,QAA0BA,OAAOC,aAC1CC,OAAOC,eAAeT,EAASM,OAAOC,YAAa,CAAEG,MAAO,WAE7DF,OAAOC,eAAeT,EAAS,aAAc,CAAEU,OAAO,K,ICsBvD,iBAME,WAAYC,EAA6BC,GAQjC,KAAAC,OAAoB,GACpB,KAAAC,YAAc,EACd,KAAAC,YAA0D,GAC1D,KAAAC,iBAAmB,EACnB,KAAAC,iBAAyC,GACzC,KAAAC,sBAAwB,EACxB,KAAAC,iBAAkB,EAbxBd,KAAKe,QAAUT,EACfN,KAAKO,OAASA,EAiOlB,OAnNU,YAAAS,gBAAR,WACE,IAAMC,EAAajB,KAAKS,YAExB,OADAT,KAAKS,YAAcQ,EAAa,EACzBA,GAGD,YAAAC,qBAAR,WACE,IAAMC,EAAkBnB,KAAKW,iBAE7B,OADAX,KAAKW,iBAAmBQ,EAAkB,EACnCA,GAGD,YAAAC,0BAAR,WACE,IAAMC,EAAuBrB,KAAKa,sBAElC,OADAb,KAAKa,sBAAwBQ,EAAuB,EAC7CA,GAMT,YAAAC,gBAAA,SAAgBC,GACd,IAAIC,GAAgB,EAMpB,OALAxB,KAAKU,YAAYe,SAAQ,SAAC,G,IAACC,EAAI,KAAS,MACjBA,aAAI,EAAJA,EAAMC,KAAKL,gBAAgBI,MAC9BF,GAAgB,SAGhCxB,KAAKc,kBAAmBU,IAC1BxB,KAAKS,YAAc,EACnBT,KAAKW,iBAAmB,EACxBX,KAAKa,sBAAwB,EAC7Bb,KAAKc,iBAAkB,EACvBX,OAAOyB,OAAOL,EAAavB,KAAKe,QAAQf,OACjC,KAMX,YAAA6B,sBAAA,SAAsBC,GAAtB,WACE9B,KAAKU,YAAYe,SAAQ,SAAC,G,IAACC,EAAI,KAAS,KACtCA,SAAAA,EAAMC,KAAKE,sBAAsBC,MAGnC9B,KAAK8B,eAAiBA,EACtB9B,KAAKY,iBAAiBa,SAAQ,SAAC,EAA0BM,G,IAAzBC,EAAM,KAAM,KAAU,OAElDA,EAAO,GACP,EAAKpB,iBAAiBmB,GAAO,IAAK,MAGtC/B,KAAK8B,oBAAiBG,GAMxB,YAAAC,SAAA,SAAYC,GACV,IAAMlB,EAAajB,KAAKgB,kBAClBoB,EAAWpC,KAAKQ,OAAOS,GAG7B,GAAImB,EAAU,OAAOA,EAIrB,IAAMC,EAAMrC,KACNsC,EAA2B,GAmBjC,OAlBAA,EAAM,GACoB,mBAAjBH,EACFA,IACDA,EACNG,EAAM,GAAK,SAACC,GACV,IAAMC,EAAeF,EAAM,GACrBG,EACmB,mBAAhBF,EACFA,EAAgCC,GACjCD,EAEFE,IAAaD,IACfF,EAAM,GAAKG,EAEXJ,EAAIvB,iBAAkB,IAG1Bd,KAAKQ,OAAOS,GAAcqB,EACnBA,GAGT,YAAAI,aAAA,SACEP,GAEA,IAAMlB,EAAajB,KAAKkB,uBAClBkB,EAAWpC,KAAKU,YAAYO,GAGlC,GAAImB,EAAU,OAAOA,EAIrB,IAAMC,EAAMrC,KACNsC,EAA2B,GAqBjC,OApBAA,EAAM,GACoB,mBAAjBH,EACFA,IACDA,EACNG,EAAM,GAAK,SAACC,GACV,IAAMC,EAAeF,EAAM,GACrBG,EACmB,mBAAhBF,EACFA,EAAgCC,GACjCD,EAEFE,IAAaD,IACfF,EAAM,GAAKG,EAEXJ,EAAIvB,iBAAkB,IAG1Bd,KAAKU,YAAYO,GAAcqB,EAGxBA,GAGT,YAAAK,gBAAA,SACEC,EACAC,GAEA,IAAM5B,EAAajB,KAAKgB,kBAClBoB,EAAWpC,KAAKQ,OAAOS,GAG7B,IAAKmB,EAAU,CACb,IAAM,EAAcQ,EAAO5C,MAE3B,OADAA,KAAKQ,OAAOS,GAAc,CAAC,EAAa4B,GACjC,EAKT,GAAIA,EAAKC,OAAM,SAACC,EAAKhB,GAAU,OAAAgB,IAAQX,EAAS,GAAGL,MACjD,OAAOK,EAAS,GAGlB,IAAMY,EAAcJ,EAAO5C,MACrBiD,EAAcb,EAAS,GAS7B,OARAA,EAAS,GAAKY,EACdZ,EAAS,GAAKS,EAGVI,GAA8C,mBAAxBA,EAAYC,SACpCD,EAAYC,UAGPF,GAGT,YAAAG,cAAA,SACEnB,EACAa,GAEA,IAAM5B,EAAajB,KAAKoB,4BAClBgB,EAAWpC,KAAKY,iBAAiBK,GAGlCmB,EAODS,EAAKC,OAAM,SAACC,EAAKhB,GAAU,OAAAgB,IAAQX,EAAS,GAAGL,QAInDK,EAAS,GAAKJ,EACdI,EAAS,GAAKS,EACdT,EAAS,IAAK,GAZZpC,KAAKY,iBAAiBK,GAAc,CAACe,EAAQa,GAAM,IAgBvD,YAAAO,WAAA,SACEC,EACAR,GAEA,IAAM5B,EAAajB,KAAKgB,kBAClBoB,EAAWpC,KAAKQ,OAAOS,GAG7B,GAAKmB,EAQDS,EAAKC,OAAM,SAACC,EAAKhB,GAAU,OAAAgB,IAAQX,EAAS,GAAGL,QAG/CK,EAAS,IAAIA,EAAS,KAI1BA,EAAS,GAAKiB,EAAO,IACrBjB,EAAS,GAAKS,OAhBd,CACE,IAAMS,EAAWD,EAAO,IACxBrD,KAAKQ,OAAOS,GAAc,CAACqC,EAAUT,KAiB3C,EAzOA,G,gNCjBO,SAASU,EACdlB,GAEA,OAAOA,EAAIH,cAAwBD,GAa9B,SAASuB,EACdnB,GAEA,OAAOA,EAAIK,kBAAkCT,GAGxC,SAASwB,EAAWpB,EAAc/B,GACvC,OAAO+B,EAAIK,cAAsB,WAAM,OCdlC,SACLnC,EACAD,GAEA,IAAM+B,EAAM,IAAIqB,EAAyBpD,EAAQC,GACjD,OAAO,EAAP,KAAYD,EAAO+B,IAAI,CAAEV,KAAMU,IDSQX,CAAKW,EAAI9B,OAAQD,MAAS,GAG5D,SAASqD,EACdtB,EACAO,EACAC,GAEA,OAAOR,EAAIM,gBAAmBC,EAAQC,GAGjC,SAASe,EACdvB,EACAL,EACAa,GAEAR,EAAIc,cAAcnB,EAAQa,G,QE7C5B,WAIE,WAAYgB,GAFZ,KAAAC,SAA+B,GAG7B9D,KAAK+D,eAAiBF,EAe1B,OAZE,YAAAG,UAAA,SAAUC,GACJjE,KAAK8D,SAASI,SAASD,IAC3BjE,KAAK8D,SAASK,KAAKF,IAGrB,YAAAG,YAAA,SAAYtC,GACV,IAAMuC,EAASrE,KAAK+D,eAAeO,oBACnCtE,KAAK8D,SAASrC,SAAQ,SAACwC,GACrBA,EAAOM,gBAAgBF,GACvBJ,EAAOO,SAAS1C,OAGtB,EApBA,GCMe,SAAS2C,EAAiBpC,GACjC,MAAwCkB,EAAgBlB,GAAvDqC,EAAe,KAAEC,EAAkB,KAEpCC,EAASjB,EACbtB,GACA,SAACA,GACC,OAAAA,EAAI9B,OAAOsE,aAAa,CACtBC,KAZuB,IAavBC,MAAOC,eAAeC,OAASD,eAAeE,aAElD,IAuCF,OApCAtB,EACEvB,GACA,SAACA,GACC,GAAKuC,EAAL,CAEA,IAAIO,EAAO,EACPC,EAAO,EACPC,EAAO,EACPC,EAAO,EAEPZ,IACEA,EAAkB,EAEpBY,EAAO,GADPD,EAAO,GAAM,GAAMX,GAInBU,EAAO,GADPD,EAAO,GAAM,GAAMT,IAMvB,IAAMa,EAAO,IAAIC,aAAa,CAE1B,EAAG,EAAG,EAAG,EAAGJ,EAAMC,GAClB,GAAG,EAAG,EAAG,EAAGF,EAAMG,GAClB,EAAG,EAAG,EAAG,EAAGH,EAAME,EAClB,EAAG,EAAG,EAAG,EAAGD,EAAMC,EAClB,GAAG,EAAG,EAAG,EAAGD,EAAME,GAClB,GAAG,EAAG,EAAG,EAAGH,EAAMG,IAGtBjD,EAAI9B,OAAOkF,MAAMC,YAAYd,EAAQ,EAAGW,EAAM,EAAGA,EAAKI,WAExD,CAACf,EAAQF,IAGJ,CACLC,mBAAkB,EAClBiB,kBAzDsB,EA0DtBC,uBAzD2B,IA0D3BC,wBAzD4B,GA0D5BC,4BAzDgC,EA0DhCC,0BAzD8B,GA0D9BC,wBAAyBrB,GC5Dd,SAASsB,EAAkB7D,GAClC,MCQO,SAAkBA,GACzB,MAAkCmB,EAA0BnB,GAA3D8D,EAAY,KAAEC,EAAe,KAC9B,EAAoC5C,EAA2BnB,GAA9DgE,EAAa,KAAEC,EAAgB,KAChC,EAAkC/C,EAAoBlB,GAArDkE,EAAY,KAAEhC,EAAe,KAE9BiC,EAA4BH,aAAa,EAAbA,EAAeG,0BAE3CC,EAAe9C,EACnBtB,GACA,SAACA,GACC,OAAAA,EAAI9B,OAAOmG,mBAAmB,CAC5BC,KC1BR,ylBD4BI,IAGIC,EAAiBjD,EACrBtB,GACA,SAACA,GACC,OAAA8D,GACA9D,EAAI9B,OAAOsG,qBAAqB,CAC9BC,OAAQ,CACNlH,OAAQ6G,EACRM,WAAY,iBACZC,QAAS,CACP,CACEC,YAAad,EAAaL,wBAC1BoB,WAAY,CACV,CACEC,eAAgB,EAChBC,OAAQjB,EAAaJ,4BACrBsB,OAAQ,aAEV,CACEF,eAAgB,EAChBC,OAAQjB,EAAaH,0BACrBqB,OAAQ,iBAMlBC,SAAU,CACR1H,OAAQ6G,EACRM,WAAY,mBACZQ,QAAS,CACP,CAEEF,OAAQ,gBAIdG,UAAW,CACTC,SAAU,iBAEZC,YAAQC,MAEZ,CAAClB,EAAcN,IAGXyB,EAAUjE,EACdtB,GACA,SAACA,GACC,OAAAA,EAAI9B,OAAOsH,cAAc,CACvBC,UAAW,SACXC,UAAW,aAEf,IAGIC,EAAYrE,EAChBtB,GACA,SAACA,GACC,OAAAuE,GACAJ,GACAnE,EAAI9B,OAAO0H,gBAAgB,CACzBP,OAAQd,EAAesB,mBAAmB,GAC1CC,QAAS,CACP,CACEC,QAAS,EACTC,SAAUT,GAEZ,CACEQ,QAAS,EACTC,SAAU7B,EAA0B8B,mBAK5C,CAAC1B,EAAgBJ,EAA2BoB,IA+B9C,OA5BAhE,EACEvB,GACA,SAACA,GACC,GAAKgE,GACAF,GACAS,GACAoB,GACAzB,EAAL,CAEA,IAAMgC,EAAclG,EAAIP,eAAe0G,gBAAgB,CACrDC,iBAAkB,CAChB,CACEC,KAAMnC,EAAa+B,aACnBK,WAAY,CAAEC,EAAG,EAAKC,EAAG,EAAKC,EAAG,EAAKC,EAAG,GACzCC,OAAQ,QACRC,QAAS,YAIfV,EAAYW,YAAYtC,GACxB2B,EAAYY,gBAAgB,EAAGhD,EAAaF,yBAC5CsC,EAAYa,aAAa,EAAGpB,GAC5BO,EAAYc,KAAKlD,EAAaP,kBAAmB,EAAG,EAAG,GACvD2C,EAAYe,SAEd,CAACjD,EAAeF,EAAcS,EAAgBoB,EAAWzB,IAGpD,CACLD,iBAAgB,EAChBF,gBAAe,EACf7B,gBAAe,GDnI8C,CAASlC,GAAhEiE,EAAgB,mBAAEF,EAAe,kBAAE7B,EAAe,kBAEpDgF,EAAO9F,EAAQpB,EAAKoC,GAS1B,OARA2B,EAAgBmD,GAMhBA,EAAK5E,mBAAmB,IAAM,MAEvB,CAAE2B,iBAAgB,EAAE/B,gBAAe,GGE7B,SAASiF,EAAsBnH,GACtC,MAAoCmB,EAA2BnB,GAA9DgE,EAAa,KAAEC,EAAgB,KAChC,EAA8B/C,EAAsBlB,GAAnDoH,EAAU,KAAEC,EAAa,KAE1BlD,EAA4BH,aAAa,EAAbA,EAAeG,0BAiC3CmD,EAAehG,EACnBtB,GACA,SAACA,GACC,OAAAoH,aAAU,EAAVA,EAAYG,aACZvH,EAAI9B,OAAOsE,aAAa,CACtBC,KAAM2E,aAAU,EAAVA,EAAYG,WAClB7E,MAAOC,eAAe6E,QAAU7E,eAAeE,aAEnD,CAACuE,aAAU,EAAVA,EAAYG,aAGfhG,EACEvB,GACA,SAACA,GACMsH,GACAF,GAELpH,EAAI9B,OAAOkF,MAAMC,YACfiE,EACA,EACAF,EACA,EACAA,EAAW9D,UAGf,CAACgE,EAAcF,IAGjB,IAAMK,EAAkBnG,EACtBtB,GACA,SAACA,GAEC,GACO,MADCoH,aAAU,EAAVA,EAAY9D,QAQpB,MCjGN,igDDiGatD,EAAI9B,OAAOwJ,sBAAsB,CACtCC,QAAS,CACPpK,OAAQyC,EAAI9B,OAAOmG,mBAAmB,CACpCC,KCpGZ,mgDDsGUI,WAAY,mCAEdW,YAAQC,MAGZ,CAAC8B,aAAU,EAAVA,EAAY9D,SAaTsE,GAVUtG,EACdtB,GACA,SAACA,GACC,OAAAA,EAAI9B,OAAOsH,cAAc,CACvBC,UAAW,SACXC,UAAW,aAEf,IAGcpE,EACdtB,GACA,SAACA,GACC,OAAAA,EAAI9B,OAAO2J,cAAc,CACvB7C,OAAQ,aACRvC,KAAM,CACJqF,OAAO3D,aAAyB,EAAzBA,EAA2B2D,QAAS,IAC3CC,QAAQ5D,aAAyB,EAAzBA,EAA2B4D,SAAU,MAE/CrF,MACEsF,gBAAgBnF,SAChBmF,gBAAgBC,gBAChBD,gBAAgBE,oBAEtB,CAAC/D,KAGGwB,EAAYrE,EAChBtB,GACA,SAACA,GACC,OAAAyH,GACAH,GACAnD,GACAyD,GACA5H,EAAI9B,OAAO0H,gBAAgB,CACzBP,OAAQoC,EAAgB5B,mBAAmB,GAC3CC,QAAS,CACP,CACEC,QAAS,EACTC,SAAU,CAAEzD,OAAQ+E,IAEtB,CACEvB,QAAS,EACTC,SAAU7B,EAA0B8B,cAEtC,CACEF,QAAS,EACTC,SAAU4B,EAAQ3B,mBAI1B,CAACwB,EAAiBH,EAAcnD,EAA2ByD,IA2B7D,OAxBArG,EACEvB,GACA,SAACA,GACC,GAAKmE,GACAsD,GACA9B,EAAL,CAEA,IAGMO,EAAclG,EAAIP,eAAe0I,mBACvCjC,EAAYW,YAAYY,GACxBvB,EAAYa,aAAa,EAAGpB,GAC5BO,EAAYkC,UACTjE,EAA0B2D,OAAS,KAPf,IASpB3D,EAA0B4D,QAAU,MARhB,GAWvB7B,EAAYe,SAEd,CAAC9C,EAA2BsD,EAAiB9B,IAGxC,CACL1B,iBAAgB,EAChBoE,aApKF,SACEC,EACAC,EACAC,EACAC,G,QAGA,QAHA,IAAAA,IAAAA,EAAA,IAGIA,EAAKC,OAASD,EAAKE,UAAW,CAChC,IAAID,EAAkB,QAAV,EAAAD,EAAKC,aAAK,QAAI,EAC1B,GAAID,EAAKE,UAAW,CAClB,IAAIC,EAAM,EACVA,EAAMN,EAAKO,QAAO,SAACC,EAAOC,GAAM,OAAAD,EAAQC,IAAGH,GAC3CA,EAAML,EAAKM,QAAO,SAACC,EAAOC,GAAM,OAAAD,EAAQC,IAAGH,GAE/B,KADZA,EAAMJ,EAAKK,QAAO,SAACC,EAAOC,GAAM,OAAAD,EAAQC,IAAGH,MAC5BF,GAAgBE,GAEnB,IAAVF,IACFJ,EAAOA,EAAKU,KAAI,SAACD,GAAM,OAAAA,EAAIL,KAC3BH,EAAOA,EAAKS,KAAI,SAACD,GAAM,OAAAA,EAAIL,KAC3BF,EAAOA,EAAKQ,KAAI,SAACD,GAAM,OAAAA,EAAIL,MAI/B,IAAMO,EAAgB,IAAI9F,aAAa,IACvC8F,EAAc,GAAc,QAAT,EAAAR,EAAKS,YAAI,QAAI,EAChCD,EAAcE,IAAIb,EAAM,GACxBW,EAAcE,IAAIZ,EAAM,GACxBU,EAAcE,IAAIX,EAAM,GACxBnB,EAAc4B,IAyId9E,0BAA2ByD,GE5LhB,SAASwB,EAA2BpJ,GAAnD,WACQ,ECAO,SAA6BA,G,QACpC,EAAgCkB,EAAqBlB,GAApDqJ,EAAW,KAAEC,EAAc,KAC5B,EAAoBpI,EAAgBlB,GAAnCuJ,EAAK,KAAEC,EAAQ,KAEhBC,EAAiC,QAAlB,EAAAJ,aAAW,EAAXA,EAAavB,aAAK,QAAI,GACrC4B,EAAmC,QAAnB,EAAAL,aAAW,EAAXA,EAAatB,cAAM,QAAI,GAEvCH,EAAUtG,EACdtB,GACA,SAACA,GACC,OAAAA,EAAI9B,OAAO2J,cAAc,CACvB0B,MAAK,EACL9G,KAAM,CAACgH,EAAcC,EAAe,GACpC1E,OAAQ,aACRtC,MACEsF,gBAAgBE,gBAChBF,gBAAgBnF,SAChBmF,gBAAgB2B,sBAEtB,CAACF,EAAcC,EAAeH,IAkBhC,OAfAhI,EACEvB,GACA,SAACA,GACMqJ,GACAzB,GAEL5H,EAAI9B,OAAOkF,MAAMwG,2BACf,CAAEC,OAAQR,GACV,CAAEzB,QAASA,GACX,CAACyB,EAAYvB,MAAOuB,EAAYtB,WAGpC,CAACsB,EAAazB,IAGT,CACL0B,eAAc,EACdE,SAAQ,EACRrF,0BAA2ByD,GDvC3BkC,CAAoB9J,GADdsJ,EAAc,iBAAEE,EAAQ,WAAErF,EAAyB,4BAGrD,EAAgBjD,EAAgBlB,GAA/B+J,EAAG,KAAEC,EAAM,KAiBlB,OAhBAR,EAASO,GT4CJ,SACL/J,EACAiK,EACAjJ,EACAR,GAEOR,EAAIe,YAAW,SAACf,GACrB,I,QAAIkK,GAAY,EAOhB,O,ESrDU,E,OAAA,E,OAAA,E,EAAA,W,2lCACR,OAAKH,IACCI,EAAMC,SAASC,cAAc,QAC/BC,IAAMP,EACV,GAAMI,EAAII,WAHA,I,OAIU,OADpB,SACoB,GAAMC,kBAAkBL,I,OAC5C,MAAO,CAAP,EADoB,e,2QT2CnBM,MAAK,SAACzM,GAAU,OAAAkM,GAAaD,EAAUjM,MAClC,OAAC,SAAC0M,GACNC,QAAQD,MAAMA,GACdR,GAAY,KAET,WACLA,GAAY,KAEb1J,GS3DHoK,CACE5K,EACAsJ,EACA,EAQA,CAACS,IAGI,CACLC,OAAM,EACN7F,0BAAyB,G,i1CEa7B,SAAe0G,EACbC,G,YAAA,IAAAA,IAAAA,EAAA,oB,yFAEA,IAAKC,UAAUC,IACb,MAAM,IAAIC,MAAM,6CAEN,SAAMF,UAAUC,IAAIE,eAAe,CAAEJ,gBAAe,K,OAChE,KADME,EAAM,UACF,MAAM,IAAIC,MAAM,kCAE1B,MAAO,CAAP,EAAOD,EAAIG,wBAGb,SAAeC,EACbC,EACAnN,G,2EAKA,KAHMoN,EAASlB,SAASiB,cACtBA,IAEW,MAAM,IAAIJ,MAAM,6CAG7B,KADMzJ,EAAgB8J,EAAOC,WAAW,WACpB,MAAM,IAAIN,MAAM,0CAQpC,OANAzJ,EAAcgK,UAAU,CACtBtN,OAAM,EACN8G,OAAQyG,IACRC,UAAW,WAGN,CAAP,EAAOlK,SAGT,SAASiK,I,QAEDA,EACmC,QAAvC,EAAa,QAAb,EAAAV,UAAUC,WAAG,eAAES,gCAAwB,eAAEE,KAAKZ,UAAUC,KAC1D,OAAIS,EAAiCA,IAG9B,a,IAvEuBG,E,OAAAA,ECExB,SAAC5L,GACP,IAAMgE,EAAgB5C,EAAQpB,EAAKoJ,GACnCpF,EAAcgG,OAAO,yBAErB,IAAM6B,EAAkBzK,EAAQpB,EAAKmH,GACrC0E,EAAgB5H,iBAAiBD,GACjC6H,EAAgBxD,aAEd,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,EAAE,GAAI,GAAI,GACV,CAAEK,MAAO,GAAKQ,KAAM,KAGtB,IAAM,EAAiC9H,EAAQpB,EAAK6D,GAA5C3B,EAAe,kBAGvB,O,yUAHkC,GAA5B,qBACC+B,iBAAiB4H,GAEjB,CAAE3J,gBAAe,IDN1B,SAAsB4J,GAClB,EADJ,UACI,qBAMA,SAASC,KAsDb,SAA6B7N,EAAmB8N,GAC9C,IAAMvM,EAAiBvB,EAAO+N,uBAC9BD,EAAQvM,GACRvB,EAAOkF,MAAM8I,OAAO,CAACzM,EAAe0M,WAxDhCC,CAAoBlO,EAAQ8N,GAC5BK,sBAAsBN,G,4DAPT,SAAMlB,K,OACC,SAAMO,EAAiB,cADvClN,EAAS,W,cACTsD,EAAgB,SAEhBwK,EAjBK,SAAC9N,EAAQsD,GACpB,IAAMI,EVuBH,SACL1D,EACAD,GAEA,IAAM+B,EAAM,IAAIqB,EAAyBpD,EAAQC,GAC3CoO,EAAW,OAAKrO,EAAO+B,IAAI,CAAEV,KAAMU,IAGzC,OAFAsM,EAASnK,SAAW,SAAC1C,GACnB,OAbJ,SAAsBJ,EAAeI,GACnC,IAAMO,EAAMX,EAAKC,KACjBU,EAAIf,gBAAgBI,GACpBW,EAAIR,sBAAsBC,GAUxB8M,CAAUD,EAAU7M,IACf6M,EU/BUE,CAAetO,EAAQ0N,GAEhCa,EAAS,IAAI,EAAajL,GAGhC,OAFAiL,EAAO9K,UAAUC,GAEV,SAAenC,GACpBgN,EAAO1K,YAAYtC,IAULqM,CAAQ5N,EAAQsD,GAMhC6K,sBAAsBN,G,WACd,OAAC,SAACrB,GACVN,SAASiB,cAAc,QAASqB,UAAYhC,EAC5CC,QAAQD,MAAMA,MA1BhBiC,G","sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/webpack/runtime/make namespace object","webpack://beta/../gpu-fu/src/Context.ts","webpack://beta/../gpu-fu/src/hooks.ts","webpack://beta/../gpu-fu/src/Unit.ts","webpack://beta/../incubator/src/OutputCanvas.ts","webpack://beta/../incubator/src/VertexSourceRect.ts","webpack://beta/../incubator/src/RenderTextureRect.ts","webpack://beta/../incubator/src/RenderUV.ts","webpack://beta/../incubator/src/RenderUV.wgsl","webpack://beta/../incubator/src/TextureFilterConvolve.ts","webpack://beta/../incubator/src/TextureFilterConvolve3x3.wgsl","webpack://beta/../incubator/src/TextureSourceBitmapFromURL.ts","webpack://beta/../incubator/src/TextureSourceBitmap.ts","webpack://beta/./src/runDemo.ts","webpack://beta/./src/demo3.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference types=\"@webgpu/types\" />\n\nimport { Unit } from \"./Unit\"\n\nexport type UpdatePropFn<T> = (currentValue: T) => T\nexport type SetPropFn<T> = (newValue: T | UpdatePropFn<T>) => void\nexport type PropStoreItem<T> = [T, SetPropFn<T>]\n\nexport type MaybeDestroyableGPUResource =\n  | undefined\n  | 0\n  | false\n  | null\n  | (GPUObjectBase & { destroy?: () => void })\nexport type StoreItemGPUResource<T extends MaybeDestroyableGPUResource> = [\n  T,\n  unknown[],\n]\n\nexport type StoreItemGPUAction = [\n  (ctx: ContextForGPUAction) => void,\n  unknown[],\n  boolean,\n]\n\nexport type StoreItemEffect = [() => void | undefined, unknown[]]\n\nexport class ContextImplementation<U> {\n  private _unitFn: (ctx: Context) => U\n\n  device: GPUDevice\n  commandEncoder?: GPUCommandEncoder\n\n  constructor(unitFn: (ctx: Context) => U, device: GPUDevice) {\n    this._unitFn = unitFn\n    this.device = device\n  }\n\n  ///\n  // This next section relates to private storage of state and effects.\n\n  private _store: unknown[] = []\n  private _storeIndex = 0\n  private _storeUnits: PropStoreItem<Unit<unknown> | undefined>[] = []\n  private _storeUnitsIndex = 0\n  private _storeGPUActions: StoreItemGPUAction[] = []\n  private _storeGPUActionsIndex = 0\n  private _needsUnitReRun = true\n\n  private _nextStoreIndex() {\n    const storeIndex = this._storeIndex\n    this._storeIndex = storeIndex + 1\n    return storeIndex\n  }\n\n  private _nextStoreUnitsIndex() {\n    const storeUnitsIndex = this._storeUnitsIndex\n    this._storeUnitsIndex = storeUnitsIndex + 1\n    return storeUnitsIndex\n  }\n\n  private _nextStoreGPUActionsIndex() {\n    const storeGPUActionsIndex = this._storeGPUActionsIndex\n    this._storeGPUActionsIndex = storeGPUActionsIndex + 1\n    return storeGPUActionsIndex\n  }\n\n  ///\n  // This next section has public methods related to running the unit.\n\n  runUnitIfNeeded(currentUnit: U) {\n    var otherUnitsRan = false\n    this._storeUnits.forEach(([unit, setUnit]) => {\n      const otherUnitRan = unit?._ctx.runUnitIfNeeded(unit)\n      if (otherUnitRan) otherUnitsRan = true\n    })\n\n    if (this._needsUnitReRun || otherUnitsRan) {\n      this._storeIndex = 0\n      this._storeUnitsIndex = 0\n      this._storeGPUActionsIndex = 0\n      this._needsUnitReRun = false\n      Object.assign(currentUnit, this._unitFn(this))\n      return true\n    } else {\n      return false\n    }\n  }\n\n  runGPUActionsIfNeeded(commandEncoder: GPUCommandEncoder) {\n    this._storeUnits.forEach(([unit, setUnit]) => {\n      unit?._ctx.runGPUActionsIfNeeded(commandEncoder)\n    })\n\n    this.commandEncoder = commandEncoder\n    this._storeGPUActions.forEach(([action, deps, needsRun], index) => {\n      if (needsRun) {\n        action(this as ContextForGPUAction)\n        this._storeGPUActions[index][2] = false\n      }\n    })\n    this.commandEncoder = undefined\n  }\n\n  ///\n  // This next section has public methods\n\n  _useProp<T>(initialValue: (() => T) | T): [T, SetPropFn<T>] {\n    const storeIndex = this._nextStoreIndex()\n    const existing = this._store[storeIndex] as PropStoreItem<T>\n\n    // If there is an existing prop/setProp pair, return it now.\n    if (existing) return existing\n\n    // Otherwise create, store, and return a new prop/setProp pair,\n    // using the provided initial state value or function.\n    const ctx = this\n    const store: [T, SetPropFn<T>] = [] as unknown as PropStoreItem<T>\n    store[0] =\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue\n    store[1] = (newValueArg) => {\n      const currentValue = store[0]\n      const newValue =\n        typeof newValueArg === \"function\"\n          ? (newValueArg as UpdatePropFn<T>)(currentValue)\n          : newValueArg\n\n      if (newValue !== currentValue) {\n        store[0] = newValue\n        // This change necessitates re-running the function with new state.\n        ctx._needsUnitReRun = true\n      }\n    }\n    this._store[storeIndex] = store\n    return store\n  }\n\n  _useUnitProp<T extends Unit<unknown> | undefined>(\n    initialValue: (() => T) | T,\n  ): [T, SetPropFn<T>] {\n    const storeIndex = this._nextStoreUnitsIndex()\n    const existing = this._storeUnits[storeIndex] as unknown as PropStoreItem<T>\n\n    // If there is an existing prop/setProp pair, return it now.\n    if (existing) return existing\n\n    // Otherwise create, store, and return a new prop/setProp pair,\n    // using the provided initial state value or function.\n    const ctx = this\n    const store: [T, SetPropFn<T>] = [] as unknown as PropStoreItem<T>\n    store[0] =\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue\n    store[1] = (newValueArg) => {\n      const currentValue = store[0]\n      const newValue =\n        typeof newValueArg === \"function\"\n          ? (newValueArg as UpdatePropFn<T>)(currentValue)\n          : newValueArg\n\n      if (newValue !== currentValue) {\n        store[0] = newValue\n        // This change necessitates re-running the function with new state.\n        ctx._needsUnitReRun = true\n      }\n    }\n    this._storeUnits[storeIndex] = store as unknown as PropStoreItem<\n      Unit<unknown> | undefined\n    >\n    return store\n  }\n\n  _useGPUResource<T extends MaybeDestroyableGPUResource>(\n    create: (ctx: ContextForGPUResource) => T,\n    deps: Array<unknown>,\n  ): T {\n    const storeIndex = this._nextStoreIndex()\n    const existing = this._store[storeIndex] as StoreItemGPUResource<T>\n\n    // If the resource has never been created, create it now.\n    if (!existing) {\n      const newResource = create(this)\n      this._store[storeIndex] = [newResource, deps]\n      return newResource\n    }\n\n    // If the resource exists, and all new dependencies have the same identity\n    // as the corresponding old dependencies, return the existing resource.\n    if (deps.every((dep, index) => dep === existing[1][index]))\n      return existing[0]\n\n    // Create the new resource and store it along with its dependencies.\n    const newResource = create(this)\n    const oldResource = existing[0]\n    existing[0] = newResource\n    existing[1] = deps\n\n    // Destroy the old resource if applicable.\n    if (oldResource && typeof oldResource.destroy === \"function\")\n      oldResource.destroy()\n\n    // Return the new resource\n    return newResource\n  }\n\n  _useGPUAction(\n    action: (ctx: ContextForGPUAction) => void,\n    deps: Array<unknown>,\n  ): void {\n    const storeIndex = this._nextStoreGPUActionsIndex()\n    const existing = this._storeGPUActions[storeIndex] as StoreItemGPUAction\n\n    // If the action has never been stored, store it now and return early.\n    if (!existing) {\n      this._storeGPUActions[storeIndex] = [action, deps, true]\n      return\n    }\n\n    // If the action is known, and all new dependencies have the same identity\n    // as the corresponding old dependencies, return without doing anything.\n    if (deps.every((dep, index) => dep === existing[1][index])) return\n\n    // Update the action function along with its dependencies,\n    // and mark it as being \"dirty\" (i.e. in need of being executed again).\n    existing[0] = action\n    existing[1] = deps\n    existing[2] = true\n    return\n  }\n\n  _useEffect(\n    effect: (ctx: ContextEmpty) => () => void | undefined,\n    deps: Array<unknown>,\n  ) {\n    const storeIndex = this._nextStoreIndex()\n    const existing = this._store[storeIndex] as StoreItemEffect\n\n    // If the effect has never been stored, store it now after executing.\n    if (!existing) {\n      const cancelFn = effect({})\n      this._store[storeIndex] = [cancelFn, deps]\n      return\n    }\n\n    // If the effect is known, and all new dependencies have the same identity\n    // as the corresponding old dependencies, return without doing anything.\n    if (deps.every((dep, index) => dep === existing[1][index])) return\n\n    // Call the existing cancel function if there is one.\n    if (existing[0]) existing[0]()\n\n    // Execute the effect function to get the new cancel function, then\n    // store it along with the new dependency identities.\n    existing[0] = effect({})\n    existing[1] = deps\n    return\n  }\n}\n\nexport type Context = Pick<\n  ContextImplementation<unknown>,\n  // In the main function context, hooks are available.\n  | \"device\"\n  | \"_useProp\"\n  | \"_useUnitProp\"\n  | \"_useGPUResource\"\n  | \"_useGPUAction\"\n  | \"_useEffect\"\n>\n\nexport type ContextForGPUResource = Pick<\n  ContextImplementation<unknown>,\n  // No hooks are available.\n  \"device\"\n>\n\nexport type ContextForGPUAction = Pick<\n  ContextImplementation<unknown>,\n  // No hooks are available, but a command encoder is available.\n  \"device\"\n> & { commandEncoder: GPUCommandEncoder }\n\nexport type ContextEmpty = {}\n","import {\n  Context,\n  ContextForGPUResource,\n  ContextForGPUAction,\n  SetPropFn,\n  MaybeDestroyableGPUResource,\n  ContextEmpty,\n} from \"./Context\"\nimport { Unit, UnitFn, NotAUnit, unit } from \"./Unit\"\n\nexport function useProp<T>(\n  ctx: Context,\n): [NotAUnit<T> | undefined, SetPropFn<NotAUnit<T> | undefined>] {\n  return ctx._useProp<T | undefined>(undefined) as [\n    NotAUnit<T> | undefined,\n    SetPropFn<NotAUnit<T> | undefined>,\n  ]\n}\n\nexport function useInitializedProp<T>(\n  ctx: Context,\n  initialValue: (() => NotAUnit<T>) | NotAUnit<T>,\n): [NotAUnit<T>, SetPropFn<NotAUnit<T>>] {\n  return ctx._useProp<NotAUnit<T>>(initialValue)\n}\n\nexport function useUnitProp<U>(\n  ctx: Context,\n): [Unit<U> | undefined, SetPropFn<Unit<U> | undefined>] {\n  return ctx._useUnitProp<Unit<U> | undefined>(undefined)\n}\n\nexport function useUnit<U>(ctx: Context, unitFn: UnitFn<U>): Unit<U> {\n  return ctx._useUnitProp<Unit<U>>(() => unit(ctx.device, unitFn))[0]\n}\n\nexport function useGPUResource<T extends MaybeDestroyableGPUResource>(\n  ctx: Context,\n  create: (ctx: ContextForGPUResource) => T,\n  deps: Array<unknown>,\n): T {\n  return ctx._useGPUResource<T>(create, deps)\n}\n\nexport function useGPUAction(\n  ctx: Context,\n  action: (ctx: ContextForGPUAction) => void,\n  deps: Array<unknown>,\n): void {\n  ctx._useGPUAction(action, deps)\n}\n\nexport function useAsyncPropSetter<T>(\n  ctx: Context,\n  setPropFn: SetPropFn<T>,\n  effect: (ctx: ContextEmpty) => Promise<T>,\n  deps: Array<unknown>,\n) {\n  return ctx._useEffect((ctx) => {\n    var cancelled = false\n    effect(ctx)\n      .then((value) => cancelled || setPropFn(value))\n      .catch((error) => {\n        console.error(error)\n        cancelled = true\n      })\n    return () => {\n      cancelled = true\n    }\n  }, deps)\n}\n","import { Context, ContextImplementation } from \"./Context\"\n\nexport type UnitAny = {\n  _ctx: Context\n}\n\nexport type Unit<U> = U & {\n  _ctx: ContextImplementation<U>\n}\n\nexport type UnitRoot<U> = U & {\n  _ctx: ContextImplementation<U>\n  runFrame: (commandEncoder: GPUCommandEncoder) => void\n}\n\nexport type UnitFn<U> = (ctx: Context) => U\n\nexport type NotAUnit<T> = T extends UnitAny ? never : T\n\nexport function unit<U>(\n  device: GPUDevice,\n  unitFn: (ctx: Context) => U,\n): Unit<U> {\n  const ctx = new ContextImplementation<U>(unitFn, device)\n  return { ...unitFn(ctx), _ctx: ctx }\n}\n\nfunction unitFrame<U>(unit: Unit<U>, commandEncoder: GPUCommandEncoder) {\n  const ctx = unit._ctx\n  ctx.runUnitIfNeeded(unit)\n  ctx.runGPUActionsIfNeeded(commandEncoder)\n}\n\nexport function createUnitRoot<U>(\n  device: GPUDevice,\n  unitFn: (ctx: Context) => U,\n): UnitRoot<U> {\n  const ctx = new ContextImplementation<U>(unitFn, device)\n  const unitRoot = { ...unitFn(ctx), _ctx: ctx } as UnitRoot<U>\n  unitRoot.runFrame = (commandEncoder: GPUCommandEncoder) =>\n    unitFrame(unitRoot, commandEncoder)\n  return unitRoot\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Render, UnitRoot } from \"@gpu-fu/gpu-fu\"\n\nexport default class OutputCanvas {\n  _canvasContext: GPUCanvasContext\n  _renders: UnitRoot<Render>[] = []\n\n  constructor(canvasContext: GPUCanvasContext) {\n    this._canvasContext = canvasContext\n  }\n\n  addRender(render: UnitRoot<Render>) {\n    if (this._renders.includes(render)) return\n    this._renders.push(render)\n  }\n\n  outputFrame(commandEncoder: GPUCommandEncoder) {\n    const target = this._canvasContext.getCurrentTexture()\n    this._renders.forEach((render) => {\n      render.setRenderTarget(target)\n      render.runFrame(commandEncoder)\n    })\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, useProp, useGPUAction, useGPUResource } from \"@gpu-fu/gpu-fu\"\n\nconst vertexSourceCount = 6\nconst vertexSourceTotalBytes = 6 * 6 * 4\nconst vertexSourceStrideBytes = 6 * 4\nconst vertexSourceXYZWOffsetBytes = 0\nconst vertexSourceUVOffsetBytes = 4 * 4\n\nexport default function VertexSourceRect(ctx: Context) {\n  const [aspectFillRatio, setAspectFillRatio] = useProp<number>(ctx)\n\n  const buffer = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createBuffer({\n        size: vertexSourceTotalBytes,\n        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n      }),\n    [],\n  )\n\n  useGPUAction(\n    ctx,\n    (ctx) => {\n      if (!buffer) return\n\n      var uMin = 0\n      var uMax = 1\n      var vMin = 0\n      var vMax = 1\n\n      if (aspectFillRatio) {\n        if (aspectFillRatio < 1) {\n          vMin = 0.5 - 0.5 * aspectFillRatio\n          vMax = 1 - vMin\n        } else {\n          uMin = 0.5 - 0.5 / aspectFillRatio\n          uMax = 1 - uMin\n        }\n      }\n\n      // prettier-ignore\n      const data = new Float32Array([\n      // (x, y, z, w),  (u, v)\n          1, 1, 0, 1, uMax, vMin,\n         -1,-1, 0, 1, uMin, vMax,\n         -1, 1, 0, 1, uMin, vMin,\n          1, 1, 0, 1, uMax, vMin,\n          1,-1, 0, 1, uMax, vMax,\n         -1,-1, 0, 1, uMin, vMax,\n      ])\n\n      ctx.device.queue.writeBuffer(buffer, 0, data, 0, data.length)\n    },\n    [buffer, aspectFillRatio],\n  )\n\n  return {\n    setAspectFillRatio,\n    vertexSourceCount,\n    vertexSourceTotalBytes,\n    vertexSourceStrideBytes,\n    vertexSourceXYZWOffsetBytes,\n    vertexSourceUVOffsetBytes,\n    vertexSourceAsGPUBuffer: buffer,\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, useUnit } from \"@gpu-fu/gpu-fu\"\nimport RenderUV from \"./RenderUV\"\nimport VertexSourceRect from \"./VertexSourceRect\"\n\nexport default function RenderTextureRect(ctx: Context) {\n  const { setTextureSource, setVertexSource, setRenderTarget } = RenderUV(ctx)\n\n  const rect = useUnit(ctx, VertexSourceRect)\n  setVertexSource(rect)\n\n  // TODO: Use the source texture and target texture aspect ratios\n  // instead of hard-coding a number here.\n  // This doesn't yet work on the latest version of chromium, because\n  // those chromium builds don't yet expose texture width and height.\n  rect.setAspectFillRatio(850 / 1275)\n\n  return { setTextureSource, setRenderTarget }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  VertexSource,\n  TextureSource,\n  autoLayout,\n  Context,\n  useGPUResource,\n  useGPUAction,\n  useProp,\n  useUnitProp,\n} from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode from \"./RenderUV.wgsl\"\n\nexport default function RenderUV(ctx: Context) {\n  const [vertexSource, setVertexSource] = useUnitProp<VertexSource>(ctx)\n  const [textureSource, setTextureSource] = useUnitProp<TextureSource>(ctx)\n  const [renderTarget, setRenderTarget] = useProp<GPUTexture>(ctx)\n\n  const textureSourceAsGPUTexture = textureSource?.textureSourceAsGPUTexture\n\n  const shaderModule = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createShaderModule({\n        code: shaderModuleCode,\n      }),\n    [],\n  )\n\n  const renderPipeline = useGPUResource(\n    ctx,\n    (ctx) =>\n      vertexSource &&\n      ctx.device.createRenderPipeline({\n        vertex: {\n          module: shaderModule,\n          entryPoint: \"vertexRenderUV\",\n          buffers: [\n            {\n              arrayStride: vertexSource.vertexSourceStrideBytes,\n              attributes: [\n                {\n                  shaderLocation: 0,\n                  offset: vertexSource.vertexSourceXYZWOffsetBytes,\n                  format: \"float32x4\" as GPUVertexFormat,\n                },\n                {\n                  shaderLocation: 1,\n                  offset: vertexSource.vertexSourceUVOffsetBytes,\n                  format: \"float32x2\" as GPUVertexFormat,\n                },\n              ],\n            },\n          ],\n        },\n        fragment: {\n          module: shaderModule,\n          entryPoint: \"fragmentRenderUV\",\n          targets: [\n            {\n              // TODO: Remove this hard-coded value - get the real one somehow.\n              format: \"rgba8unorm\" as GPUTextureFormat,\n            },\n          ],\n        },\n        primitive: {\n          topology: \"triangle-list\",\n        },\n        layout: autoLayout(),\n      }),\n    [shaderModule, vertexSource],\n  )\n\n  const sampler = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createSampler({\n        magFilter: \"linear\",\n        minFilter: \"linear\",\n      }),\n    [],\n  )\n\n  const bindGroup = useGPUResource(\n    ctx,\n    (ctx) =>\n      renderPipeline &&\n      textureSourceAsGPUTexture &&\n      ctx.device.createBindGroup({\n        layout: renderPipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: sampler,\n          },\n          {\n            binding: 1,\n            resource: textureSourceAsGPUTexture.createView(),\n          },\n        ],\n      }),\n\n    [renderPipeline, textureSourceAsGPUTexture, sampler],\n  )\n\n  useGPUAction(\n    ctx,\n    (ctx) => {\n      if (!textureSource) return\n      if (!vertexSource) return\n      if (!renderPipeline) return\n      if (!bindGroup) return\n      if (!renderTarget) return\n\n      const passEncoder = ctx.commandEncoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: renderTarget.createView(),\n            clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n            loadOp: \"clear\" as GPULoadOp,\n            storeOp: \"store\" as GPUStoreOp,\n          },\n        ],\n      })\n      passEncoder.setPipeline(renderPipeline)\n      passEncoder.setVertexBuffer(0, vertexSource.vertexSourceAsGPUBuffer)\n      passEncoder.setBindGroup(0, bindGroup)\n      passEncoder.draw(vertexSource.vertexSourceCount, 1, 0, 0)\n      passEncoder.end()\n    },\n    [textureSource, vertexSource, renderPipeline, bindGroup, renderTarget],\n  )\n\n  return {\n    setTextureSource,\n    setVertexSource,\n    setRenderTarget,\n  }\n}\n","export default \"@group(0) @binding(0) var use_sampler: sampler;\\n@group(0) @binding(1) var use_texture: texture_2d<f32>;\\n\\nstruct VertexOutput {\\n  @builtin(position) pos: vec4<f32>;\\n  @location(0) uv: vec2<f32>;\\n}\\n\\n@stage(vertex)\\nfn vertexRenderUV(\\n  @location(0) pos_in: vec4<f32>,\\n  @location(1) uv_in: vec2<f32>,\\n) ->\\n  VertexOutput\\n{\\n  var out: VertexOutput;\\n  out.pos = pos_in;\\n  out.uv = uv_in;\\n  return out;\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderUV(\\n  @location(0) uv_in : vec2<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return textureSample(use_texture, use_sampler, uv_in.xy);\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  TextureSource,\n  autoLayout,\n  Context,\n  useGPUResource,\n  useGPUAction,\n  useProp,\n  useUnitProp,\n} from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode3x3 from \"./TextureFilterConvolve3x3.wgsl\"\n\ninterface SetKernelOptions {\n  bias?: number\n  scale?: number\n  normalize?: boolean\n}\n\nexport default function TextureFilterConvolve(ctx: Context) {\n  const [textureSource, setTextureSource] = useUnitProp<TextureSource>(ctx)\n  const [kernelData, setKernelData] = useProp<Float32Array>(ctx)\n\n  const textureSourceAsGPUTexture = textureSource?.textureSourceAsGPUTexture\n\n  function setKernel3x3(\n    row0: [number, number, number],\n    row1: [number, number, number],\n    row2: [number, number, number],\n    opts: SetKernelOptions = {},\n  ) {\n    // Respect scale and/or normalize options if present.\n    if (opts.scale || opts.normalize) {\n      var scale = opts.scale ?? 1\n      if (opts.normalize) {\n        var sum = 0\n        sum = row0.reduce((accum, n) => accum + n, sum)\n        sum = row1.reduce((accum, n) => accum + n, sum)\n        sum = row2.reduce((accum, n) => accum + n, sum)\n        if (sum !== 0) scale = scale / sum\n      }\n      if (scale !== 1) {\n        row0 = row0.map((n) => n * scale) as typeof row0\n        row1 = row1.map((n) => n * scale) as typeof row1\n        row2 = row2.map((n) => n * scale) as typeof row2\n      }\n    }\n\n    const newKernelData = new Float32Array(10)\n    newKernelData[0] = opts.bias ?? 0\n    newKernelData.set(row0, 1)\n    newKernelData.set(row1, 4)\n    newKernelData.set(row2, 7)\n    setKernelData(newKernelData)\n  }\n\n  const kernelBuffer = useGPUResource(\n    ctx,\n    (ctx) =>\n      kernelData?.byteLength &&\n      ctx.device.createBuffer({\n        size: kernelData?.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      }),\n    [kernelData?.byteLength],\n  )\n\n  useGPUAction(\n    ctx,\n    (ctx) => {\n      if (!kernelBuffer) return\n      if (!kernelData) return\n\n      ctx.device.queue.writeBuffer(\n        kernelBuffer,\n        0,\n        kernelData,\n        0,\n        kernelData.length,\n      )\n    },\n    [kernelBuffer, kernelData],\n  )\n\n  const computePipeline = useGPUResource(\n    ctx,\n    (ctx) => {\n      let shaderModuleCode: string\n      switch (kernelData?.length) {\n        case 10:\n          shaderModuleCode = shaderModuleCode3x3\n          break\n        default:\n          return\n      }\n\n      return ctx.device.createComputePipeline({\n        compute: {\n          module: ctx.device.createShaderModule({\n            code: shaderModuleCode,\n          }),\n          entryPoint: \"computeTextureFilterConvolve3x3\",\n        },\n        layout: autoLayout(),\n      })\n    },\n    [kernelData?.length],\n  )\n\n  const sampler = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createSampler({\n        magFilter: \"linear\",\n        minFilter: \"linear\",\n      }),\n    [],\n  )\n\n  const texture = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createTexture({\n        format: \"rgba8unorm\",\n        size: {\n          width: textureSourceAsGPUTexture?.width || 850, // TODO: remove fallback value\n          height: textureSourceAsGPUTexture?.height || 1275, // TODO: remove fallback value\n        },\n        usage:\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.STORAGE_BINDING |\n          GPUTextureUsage.TEXTURE_BINDING,\n      }),\n    [textureSourceAsGPUTexture],\n  )\n\n  const bindGroup = useGPUResource(\n    ctx,\n    (ctx) =>\n      computePipeline &&\n      kernelBuffer &&\n      textureSourceAsGPUTexture &&\n      texture &&\n      ctx.device.createBindGroup({\n        layout: computePipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: { buffer: kernelBuffer },\n          },\n          {\n            binding: 1,\n            resource: textureSourceAsGPUTexture.createView(),\n          },\n          {\n            binding: 2,\n            resource: texture.createView(),\n          },\n        ],\n      }),\n    [computePipeline, kernelBuffer, textureSourceAsGPUTexture, texture],\n  )\n\n  useGPUAction(\n    ctx,\n    (ctx) => {\n      if (!textureSourceAsGPUTexture) return\n      if (!computePipeline) return\n      if (!bindGroup) return\n\n      const workGroupSizeX = 32 // (must match the WGSL code)\n      const workGroupSizeY = 1 // (must match the WGSL code)\n\n      const passEncoder = ctx.commandEncoder.beginComputePass()\n      passEncoder.setPipeline(computePipeline)\n      passEncoder.setBindGroup(0, bindGroup)\n      passEncoder.dispatch(\n        (textureSourceAsGPUTexture.width || 850) / // TODO: remove fallback value\n          workGroupSizeX,\n        (textureSourceAsGPUTexture.height || 1275) / // TODO: remove fallback value\n          workGroupSizeY,\n      )\n      passEncoder.end()\n    },\n    [textureSourceAsGPUTexture, computePipeline, bindGroup],\n  )\n\n  return {\n    setTextureSource,\n    setKernel3x3,\n    textureSourceAsGPUTexture: texture,\n  }\n}\n","export default \"@group(0) @binding(0) var<uniform> kernel_3x3: Kernel3x3;\\n@group(0) @binding(1) var texture_in: texture_2d<f32>;\\n@group(0) @binding(2) var texture_out: texture_storage_2d<rgba8unorm, write>;\\n\\nstruct Kernel3x3 {\\n  bias: f32;\\n  aa: f32;\\n  ba: f32;\\n  ca: f32;\\n  ab: f32;\\n  bb: f32;\\n  cb: f32;\\n  ac: f32;\\n  bc: f32;\\n  cc: f32;\\n}\\n\\n// TODO: What is the most likely optimal workgroup size?\\n@stage(compute) @workgroup_size(32, 1, 1)\\nfn computeTextureFilterConvolve3x3(\\n  @builtin(global_invocation_id) global_id: vec3<u32>,\\n) {\\n  let b = vec2<i32>(global_id.xy);\\n  let a = max(b - 1, vec2<i32>(0));\\n  let c = min(b + 1, min(\\n    textureDimensions(texture_in),\\n    textureDimensions(texture_out),\\n  ));\\n\\n  var sum = vec4<f32>(kernel_3x3.bias);\\n\\n  sum = sum + kernel_3x3.aa * textureLoad(texture_in, vec2<i32>(a.x, a.y), 0);\\n  sum = sum + kernel_3x3.ba * textureLoad(texture_in, vec2<i32>(b.x, a.y), 0);\\n  sum = sum + kernel_3x3.ca * textureLoad(texture_in, vec2<i32>(c.x, a.y), 0);\\n\\n  sum = sum + kernel_3x3.ab * textureLoad(texture_in, vec2<i32>(a.x, b.y), 0);\\n  sum = sum + kernel_3x3.bb * textureLoad(texture_in, vec2<i32>(b.x, b.y), 0);\\n  sum = sum + kernel_3x3.cb * textureLoad(texture_in, vec2<i32>(c.x, b.y), 0);\\n\\n  sum = sum + kernel_3x3.ac * textureLoad(texture_in, vec2<i32>(a.x, c.y), 0);\\n  sum = sum + kernel_3x3.bc * textureLoad(texture_in, vec2<i32>(b.x, c.y), 0);\\n  sum = sum + kernel_3x3.cc * textureLoad(texture_in, vec2<i32>(c.x, c.y), 0);\\n\\n  textureStore(texture_out, b, sum);\\n}\\n\";","import { Context, useAsyncPropSetter, useProp } from \"@gpu-fu/gpu-fu\"\nimport TextureSourceBitmap from \"./TextureSourceBitmap\"\n\nexport default function TextureSourceBitmapFromURL(ctx: Context) {\n  const { setImageBitmap, setLabel, textureSourceAsGPUTexture } =\n    TextureSourceBitmap(ctx)\n\n  const [url, setURL] = useProp<string>(ctx)\n  setLabel(url)\n\n  useAsyncPropSetter(\n    ctx,\n    setImageBitmap,\n    async (ctx) => {\n      if (!url) return\n      const img = document.createElement(\"img\")\n      img.src = url\n      await img.decode()\n      const imageBitmap = await createImageBitmap(img)\n      return imageBitmap\n    },\n    [url],\n  )\n\n  return {\n    setURL,\n    textureSourceAsGPUTexture,\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, useProp, useGPUResource, useGPUAction } from \"@gpu-fu/gpu-fu\"\n\nexport default function TextureSourceBitmap(ctx: Context) {\n  const [imageBitmap, setImageBitmap] = useProp<ImageBitmap>(ctx)\n  const [label, setLabel] = useProp<string>(ctx)\n\n  const textureWidth = imageBitmap?.width ?? 16 // TODO: remove fallback values\n  const textureHeight = imageBitmap?.height ?? 16 // TODO: remove fallback values\n\n  const texture = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createTexture({\n        label,\n        size: [textureWidth, textureHeight, 1],\n        format: \"rgba8unorm\",\n        usage:\n          GPUTextureUsage.TEXTURE_BINDING |\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT,\n      }),\n    [textureWidth, textureHeight, label],\n  )\n\n  useGPUAction(\n    ctx,\n    (ctx) => {\n      if (!imageBitmap) return\n      if (!texture) return\n\n      ctx.device.queue.copyExternalImageToTexture(\n        { source: imageBitmap },\n        { texture: texture },\n        [imageBitmap.width, imageBitmap.height],\n      )\n    },\n    [imageBitmap, texture],\n  )\n\n  return {\n    setImageBitmap,\n    setLabel,\n    textureSourceAsGPUTexture: texture,\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { UnitFn, createUnitRoot, Render } from \"@gpu-fu/gpu-fu\"\nimport { OutputCanvas } from \"@gpu-fu/incubator\"\n\ntype FrameFn = (commandEncoder: GPUCommandEncoder) => void\ntype SetupFn = (device: GPUDevice, canvasContext: GPUCanvasContext) => FrameFn\n\nexport default function runDemo(renderFn: UnitFn<Render>) {\n  runDemoInner((device, canvasContext) => {\n    const render = createUnitRoot(device, renderFn)\n\n    const output = new OutputCanvas(canvasContext)\n    output.addRender(render)\n\n    return function frame(commandEncoder) {\n      output.outputFrame(commandEncoder)\n    }\n  })\n}\n\nfunction runDemoInner(setupFn: SetupFn) {\n  ;(async () => {\n    const device = await getDevice()\n    const canvasContext = await getCanvasContext(\"canvas.main\", device)\n\n    const frameFn = setupFn(device, canvasContext)\n\n    function repeatFrameWithContext() {\n      runFrameWithContext(device, frameFn)\n      requestAnimationFrame(repeatFrameWithContext)\n    }\n    requestAnimationFrame(repeatFrameWithContext)\n  })().catch((error) => {\n    document.querySelector(\"body\")!.innerHTML = error\n    console.error(error)\n  })\n}\n\nasync function getDevice(\n  powerPreference: GPUPowerPreference = \"high-performance\",\n): Promise<GPUDevice> {\n  if (!navigator.gpu)\n    throw new Error(\"Your browser doesn't have WebGPU enabled!\")\n\n  const gpu = await navigator.gpu.requestAdapter({ powerPreference })\n  if (!gpu) throw new Error(\"Failed to get the GPU adapter!\")\n\n  return gpu.requestDevice()\n}\n\nasync function getCanvasContext(\n  querySelector: string,\n  device: GPUDevice,\n): Promise<GPUCanvasContext> {\n  const canvas = document.querySelector(\n    querySelector,\n  ) as HTMLCanvasElement | null\n  if (!canvas) throw new Error(\"The main canvas wasn't found in the HTML!\")\n\n  const canvasContext = canvas.getContext(\"webgpu\") as GPUCanvasContext | null\n  if (!canvasContext) throw new Error(\"Failed to get a WebGPU canvas context!\")\n\n  canvasContext.configure({\n    device,\n    format: getPreferredCanvasFormat(),\n    alphaMode: \"opaque\",\n  })\n\n  return canvasContext\n}\n\nfunction getPreferredCanvasFormat() {\n  // Some browsers throw an \"Illegal invocation\" error if we don't bind.\n  const getPreferredCanvasFormat =\n    navigator.gpu?.getPreferredCanvasFormat?.bind(navigator.gpu)\n  if (getPreferredCanvasFormat) return getPreferredCanvasFormat()\n\n  // Hard-coded default for browsers that don't implement this function yet.\n  return \"rgba8unorm\"\n}\n\nfunction runFrameWithContext(device: GPUDevice, frameFn: FrameFn) {\n  const commandEncoder = device.createCommandEncoder()\n  frameFn(commandEncoder)\n  device.queue.submit([commandEncoder.finish()])\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { useUnit } from \"@gpu-fu/gpu-fu\"\nimport {\n  TextureSourceBitmapFromURL,\n  TextureFilterConvolve,\n  RenderTextureRect,\n} from \"@gpu-fu/incubator\"\n\nimport runDemo from \"./runDemo\"\nrunDemo((ctx) => {\n  const textureSource = useUnit(ctx, TextureSourceBitmapFromURL)\n  textureSource.setURL(\"./assets/fireweed.jpg\")\n\n  const sobelHorizontal = useUnit(ctx, TextureFilterConvolve)\n  sobelHorizontal.setTextureSource(textureSource)\n  sobelHorizontal.setKernel3x3(\n    // Sobel Horizontal Kernel (with scaling and bias to center on gray)\n    [1, 2, 1],\n    [0, 0, 0],\n    [-1, -2, -1],\n    { scale: 0.5, bias: 0.5 },\n  )\n\n  const { setRenderTarget, ...render } = useUnit(ctx, RenderTextureRect)\n  render.setTextureSource(sobelHorizontal)\n\n  return { setRenderTarget }\n})\n"],"names":["root","factory","exports","module","define","amd","self","this","Symbol","toStringTag","Object","defineProperty","value","unitFn","device","_store","_storeIndex","_storeUnits","_storeUnitsIndex","_storeGPUActions","_storeGPUActionsIndex","_needsUnitReRun","_unitFn","_nextStoreIndex","storeIndex","_nextStoreUnitsIndex","storeUnitsIndex","_nextStoreGPUActionsIndex","storeGPUActionsIndex","runUnitIfNeeded","currentUnit","otherUnitsRan","forEach","unit","_ctx","assign","runGPUActionsIfNeeded","commandEncoder","index","action","undefined","_useProp","initialValue","existing","ctx","store","newValueArg","currentValue","newValue","_useUnitProp","_useGPUResource","create","deps","every","dep","newResource","oldResource","destroy","_useGPUAction","_useEffect","effect","cancelFn","useProp","useUnitProp","useUnit","ContextImplementation","useGPUResource","useGPUAction","canvasContext","_renders","_canvasContext","addRender","render","includes","push","outputFrame","target","getCurrentTexture","setRenderTarget","runFrame","VertexSourceRect","aspectFillRatio","setAspectFillRatio","buffer","createBuffer","size","usage","GPUBufferUsage","VERTEX","COPY_DST","uMin","uMax","vMin","vMax","data","Float32Array","queue","writeBuffer","length","vertexSourceCount","vertexSourceTotalBytes","vertexSourceStrideBytes","vertexSourceXYZWOffsetBytes","vertexSourceUVOffsetBytes","vertexSourceAsGPUBuffer","RenderTextureRect","vertexSource","setVertexSource","textureSource","setTextureSource","renderTarget","textureSourceAsGPUTexture","shaderModule","createShaderModule","code","renderPipeline","createRenderPipeline","vertex","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","format","fragment","targets","primitive","topology","layout","autoLayout","sampler","createSampler","magFilter","minFilter","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","passEncoder","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","setVertexBuffer","setBindGroup","draw","end","rect","TextureFilterConvolve","kernelData","setKernelData","kernelBuffer","byteLength","UNIFORM","computePipeline","createComputePipeline","compute","texture","createTexture","width","height","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","beginComputePass","dispatch","setKernel3x3","row0","row1","row2","opts","scale","normalize","sum","reduce","accum","n","map","newKernelData","bias","set","TextureSourceBitmapFromURL","imageBitmap","setImageBitmap","label","setLabel","textureWidth","textureHeight","RENDER_ATTACHMENT","copyExternalImageToTexture","source","TextureSourceBitmap","url","setURL","setPropFn","cancelled","img","document","createElement","src","decode","createImageBitmap","then","error","console","useAsyncPropSetter","getDevice","powerPreference","navigator","gpu","Error","requestAdapter","requestDevice","getCanvasContext","querySelector","canvas","getContext","configure","getPreferredCanvasFormat","alphaMode","bind","renderFn","sobelHorizontal","setupFn","repeatFrameWithContext","frameFn","createCommandEncoder","submit","finish","runFrameWithContext","requestAnimationFrame","unitRoot","unitFrame","createUnitRoot","output","innerHTML","runDemoInner"],"sourceRoot":""}