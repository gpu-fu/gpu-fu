{"version":3,"file":"demo3.js","mappings":"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","sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/webpack/runtime/make namespace object","webpack://beta/./src/common/runDemo.ts","webpack://beta/./src/gpu-fu/TextureSourceBitmap.ts","webpack://beta/./src/gpu-fu/TextureFilterConvolve.ts","webpack://beta/./src/gpu-fu/TextureFilterConvolve3x3.wgsl","webpack://beta/./src/gpu-fu/RenderUV.ts","webpack://beta/./src/gpu-fu/RenderUV.wgsl","webpack://beta/./src/gpu-fu/VertexSourceRect.ts","webpack://beta/./src/gpu-fu/RenderTextureRect.ts","webpack://beta/./src/gpu-fu/OutputCanvas.ts","webpack://beta/./src/demo3.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"../gpu-fu/Context\"\n\ntype FrameFn = (ctx: Context, frame: number) => void\ntype SetupFn = (\n  device: GPUDevice,\n  canvasContext: GPUCanvasContext\n) => Promise<FrameFn>\n\nexport default function runDemo(setupFn: SetupFn) {\n  ;(async () => {\n    const device = await getDevice()\n    const canvasContext = await getCanvasContext(\"canvas.main\", device)\n\n    const frameFn = await setupFn(device, canvasContext)\n\n    var frame = 0\n    function repeatFrameWithContext() {\n      frame = frame + 1\n      runFrameWithContext(device, frame, frameFn)\n      requestAnimationFrame(repeatFrameWithContext)\n    }\n    requestAnimationFrame(repeatFrameWithContext)\n  })().catch((error) => {\n    document.querySelector(\"body\")!.innerHTML = error\n    console.error(error)\n  })\n}\n\nasync function getDevice(\n  powerPreference: GPUPowerPreference = \"high-performance\"\n): Promise<GPUDevice> {\n  if (!navigator.gpu)\n    throw new Error(\"Your browser doesn't have WebGPU enabled!\")\n\n  const gpu = await navigator.gpu.requestAdapter({ powerPreference })\n  if (!gpu) throw new Error(\"Failed to get the GPU adapter!\")\n\n  return gpu.requestDevice()\n}\n\nasync function getCanvasContext(\n  querySelector: string,\n  device: GPUDevice\n): Promise<GPUCanvasContext> {\n  const canvas = document.querySelector(\n    querySelector\n  ) as HTMLCanvasElement | null\n  if (!canvas) throw new Error(\"The main canvas wasn't found in the HTML!\")\n\n  const canvasContext = canvas.getContext(\"webgpu\") as GPUCanvasContext | null\n  if (!canvasContext) throw new Error(\"Failed to get a WebGPU canvas context!\")\n\n  canvasContext.configure({\n    device,\n    format: getPreferredCanvasFormat(),\n    alphaMode: \"opaque\",\n  })\n\n  return canvasContext\n}\n\nfunction getPreferredCanvasFormat() {\n  // Some browsers throw an \"Illegal invocation\" error if we don't bind.\n  const getPreferredCanvasFormat =\n    navigator.gpu?.getPreferredCanvasFormat?.bind(navigator.gpu)\n  if (getPreferredCanvasFormat) return getPreferredCanvasFormat()\n\n  // Hard-coded default for browsers that don't implement this function yet.\n  return \"rgba8unorm\"\n}\n\nfunction runFrameWithContext(\n  device: GPUDevice,\n  frame: number,\n  frameFn: FrameFn\n) {\n  const commandEncoder = device.createCommandEncoder()\n  frameFn({ device, commandEncoder }, frame)\n  device.queue.submit([commandEncoder.finish()])\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport TextureSource from \"./TextureSource\"\n\nexport default class TextureSourceBitmap implements TextureSource {\n  private _imageBitmap: ImageBitmap\n  private _label: string\n\n  private _texture?: GPUTexture\n\n  constructor(imageBitmap: ImageBitmap, label: string) {\n    this._imageBitmap = imageBitmap\n    this._label = label\n  }\n\n  static async fromURL(url: string, label?: string) {\n    const img = document.createElement(\"img\")\n    img.src = url\n    await img.decode()\n    const imageBitmap = await createImageBitmap(img)\n    return new TextureSourceBitmap(imageBitmap, label ?? url)\n  }\n\n  textureSourceAsGPUTexture(ctx: Context): GPUTexture {\n    if (this._texture) return this._texture\n\n    this._texture = ctx.device.createTexture({\n      label: this._label,\n      size: [this._imageBitmap.width, this._imageBitmap.height, 1],\n      format: \"rgba8unorm\",\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    })\n\n    ctx.device.queue.copyExternalImageToTexture(\n      { source: this._imageBitmap },\n      { texture: this._texture },\n      [this._imageBitmap.width, this._imageBitmap.height]\n    )\n\n    console.log(this._texture)\n\n    return this._texture\n  }\n\n  textureSourceFrame(ctx: Context, frame: number): void {}\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport TextureFilter from \"./TextureFilter\"\nimport TextureSource from \"./TextureSource\"\n\nimport shaderModuleCode3x3 from \"./TextureFilterConvolve3x3.wgsl\"\nimport { autoLayout } from \"./utils\"\n\ninterface SetKernelOptions {\n  bias?: number\n  scale?: number\n  normalize?: boolean\n}\n\nexport default class TextureFilterConvolve implements TextureFilter {\n  private _textureSource?: TextureSource\n  private _kernelData?: Float32Array\n\n  private _kernelBuffer?: GPUBuffer\n  private _kernelBufferUpToDate = false\n  private _texture?: GPUTexture\n  private _shaderModule?: GPUShaderModule\n  private _computePipeline?: GPUComputePipeline\n  private _bindGroup?: GPUBindGroup\n\n  private getKernelData(): Float32Array {\n    if (this._kernelData) return this._kernelData\n    throw new Error(`${this} has no _kernelData`)\n  }\n\n  setKernel3x3(\n    row0: [number, number, number],\n    row1: [number, number, number],\n    row2: [number, number, number],\n    opts: SetKernelOptions = {},\n  ) {\n    // Respect scale and/or normalize options if present.\n    if (opts.scale || opts.normalize) {\n      var scale = opts.scale ?? 1\n      if (opts.normalize) {\n        var sum = 0\n        sum = row0.reduce((accum, n) => accum + n, sum)\n        sum = row1.reduce((accum, n) => accum + n, sum)\n        sum = row2.reduce((accum, n) => accum + n, sum)\n        if (sum !== 0) scale = scale / sum\n      }\n      if (scale !== 1) {\n        row0 = row0.map((n) => n * scale) as typeof row0\n        row1 = row1.map((n) => n * scale) as typeof row1\n        row2 = row2.map((n) => n * scale) as typeof row2\n      }\n    }\n\n    // Create the kernel data array and fill it with data.\n    const kernelData = new Float32Array(10)\n    kernelData[0] = opts.bias ?? 0\n    kernelData.set(row0, 1)\n    kernelData.set(row1, 4)\n    kernelData.set(row2, 7)\n\n    // If the kernel size has changed, it invalidates almost everything.\n    if (kernelData.byteLength !== this._kernelData?.byteLength) {\n      this._kernelBuffer = undefined\n      this._shaderModule = undefined\n      this._computePipeline = undefined\n      this._bindGroup = undefined\n    }\n\n    // Assign the kernel data array and mark the buffer data as invalidated.\n    this._kernelData = kernelData\n    this._kernelBufferUpToDate = false\n  }\n\n  getTextureSource(): TextureSource {\n    if (this._textureSource) return this._textureSource\n    throw new Error(`${this} has no _textureSource`)\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._textureSource = textureSource\n    this._bindGroup = undefined\n  }\n\n  private getKernelBuffer(ctx: Context): GPUBuffer {\n    if (this._kernelBuffer) return this._kernelBuffer\n\n    console.log(\"byteLength\", this.getKernelData().byteLength)\n\n    const buffer = ctx.device.createBuffer({\n      size: this.getKernelData().byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    })\n\n    return (this._kernelBuffer = buffer)\n  }\n\n  private updateKernelBuffer(ctx: Context) {\n    if (this._kernelBufferUpToDate) return\n\n    const data = this.getKernelData()\n\n    ctx.device.queue.writeBuffer(\n      this.getKernelBuffer(ctx),\n      0,\n      data,\n      0,\n      data.length,\n    )\n\n    this._kernelBufferUpToDate = true\n  }\n\n  private getShaderModule(ctx: Context): GPUShaderModule {\n    if (this._shaderModule) return this._shaderModule\n\n    let shaderModuleCode: string\n    switch (this.getKernelData().length) {\n      case 10:\n        shaderModuleCode = shaderModuleCode3x3\n        break\n      default:\n        throw new Error(\"_kernelData length is invalid!\")\n    }\n\n    return (this._shaderModule = ctx.device.createShaderModule({\n      code: shaderModuleCode,\n    }))\n  }\n\n  private getComputePipeline(ctx: Context): GPUComputePipeline {\n    if (this._computePipeline) return this._computePipeline\n\n    return (this._computePipeline = ctx.device.createComputePipeline({\n      compute: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"computeTextureFilterConvolve3x3\",\n      },\n      layout: autoLayout(),\n    }))\n  }\n\n  private getBindGroup(ctx: Context) {\n    if (this._bindGroup) return this._bindGroup\n\n    const sampler = ctx.device.createSampler({\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n    })\n\n    return (this._bindGroup = ctx.device.createBindGroup({\n      layout: this.getComputePipeline(ctx).getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: this.getKernelBuffer(ctx) },\n        },\n        {\n          binding: 1,\n          resource: this.getTextureSource()\n            .textureSourceAsGPUTexture(ctx)\n            .createView(),\n        },\n        {\n          binding: 2,\n          resource: this.textureSourceAsGPUTexture(ctx).createView(),\n        },\n      ],\n    }))\n  }\n\n  textureSourceAsGPUTexture(ctx: Context): GPUTexture {\n    if (this._texture) return this._texture\n\n    const textureSource = this.getTextureSource().textureSourceAsGPUTexture(ctx)\n\n    this._texture = ctx.device.createTexture({\n      format: \"rgba8unorm\",\n      size: {\n        width: textureSource.width || 850, // TODO: remove fallback value\n        height: textureSource.height || 1275, // TODO: remove fallback value\n      },\n      usage:\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.STORAGE_BINDING |\n        GPUTextureUsage.TEXTURE_BINDING,\n    })\n\n    return this._texture\n  }\n\n  textureSourceFrame(ctx: Context, frame: number) {\n    this.updateKernelBuffer(ctx)\n\n    const textureSource = this.getTextureSource().textureSourceAsGPUTexture(ctx)\n    const workGroupSizeX = 32 // (must match the WGSL code)\n    const workGroupSizeY = 1 // (must match the WGSL code)\n\n    const passEncoder = ctx.commandEncoder.beginComputePass()\n    passEncoder.setPipeline(this.getComputePipeline(ctx))\n    passEncoder.setBindGroup(0, this.getBindGroup(ctx))\n    passEncoder.dispatch(\n      (textureSource.width || 850) / workGroupSizeX, // TODO: remove fallback value\n      (textureSource.height || 1275) / workGroupSizeY, // TODO: remove fallback value\n    )\n    passEncoder.end()\n  }\n}\n","export default \"@group(0) @binding(0) var<uniform> kernel_3x3: Kernel3x3;\\n@group(0) @binding(1) var texture_in: texture_2d<f32>;\\n@group(0) @binding(2) var texture_out: texture_storage_2d<rgba8unorm, write>;\\n\\nstruct Kernel3x3 {\\n  bias: f32;\\n  aa: f32;\\n  ba: f32;\\n  ca: f32;\\n  ab: f32;\\n  bb: f32;\\n  cb: f32;\\n  ac: f32;\\n  bc: f32;\\n  cc: f32;\\n}\\n\\n// TODO: What is the most likely optimal workgroup size?\\n@stage(compute) @workgroup_size(32, 1, 1)\\nfn computeTextureFilterConvolve3x3(\\n  @builtin(global_invocation_id) global_id: vec3<u32>,\\n) {\\n  let b = vec2<i32>(global_id.xy);\\n  let a = max(b - 1, vec2<i32>(0));\\n  let c = min(b + 1, min(\\n    textureDimensions(texture_in),\\n    textureDimensions(texture_out),\\n  ));\\n\\n  var sum = vec4<f32>(kernel_3x3.bias);\\n\\n  sum = sum + kernel_3x3.aa * textureLoad(texture_in, vec2<i32>(a.x, a.y), 0);\\n  sum = sum + kernel_3x3.ba * textureLoad(texture_in, vec2<i32>(b.x, a.y), 0);\\n  sum = sum + kernel_3x3.ca * textureLoad(texture_in, vec2<i32>(c.x, a.y), 0);\\n\\n  sum = sum + kernel_3x3.ab * textureLoad(texture_in, vec2<i32>(a.x, b.y), 0);\\n  sum = sum + kernel_3x3.bb * textureLoad(texture_in, vec2<i32>(b.x, b.y), 0);\\n  sum = sum + kernel_3x3.cb * textureLoad(texture_in, vec2<i32>(c.x, b.y), 0);\\n\\n  sum = sum + kernel_3x3.ac * textureLoad(texture_in, vec2<i32>(a.x, c.y), 0);\\n  sum = sum + kernel_3x3.bc * textureLoad(texture_in, vec2<i32>(b.x, c.y), 0);\\n  sum = sum + kernel_3x3.cc * textureLoad(texture_in, vec2<i32>(c.x, c.y), 0);\\n\\n  textureStore(texture_out, b, sum);\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport Render from \"./Render\"\nimport VertexSource from \"./VertexSource\"\nimport TextureSource from \"./TextureSource\"\n\nimport shaderModuleCode from \"./RenderUV.wgsl\"\nimport { autoLayout } from \"./utils\"\n\nexport default class RenderUV implements Render {\n  private _vertexSource?: VertexSource\n  private _textureSource?: TextureSource\n\n  private _shaderModule?: GPUShaderModule\n  private _renderPipeline?: GPURenderPipeline\n  private _bindGroup?: GPUBindGroup\n\n  getVertexSource(): VertexSource {\n    if (this._vertexSource) return this._vertexSource\n    throw new Error(`${this} has no _vertexSource`)\n  }\n\n  setVertexSource(vertexSource: VertexSource) {\n    this._vertexSource = vertexSource\n    this._renderPipeline = undefined\n    this._bindGroup = undefined\n  }\n\n  getTextureSource(): TextureSource {\n    if (this._textureSource) return this._textureSource\n    throw new Error(`${this} has no _textureSource`)\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._textureSource = textureSource\n    this._renderPipeline = undefined\n    this._bindGroup = undefined\n  }\n\n  getShaderModule(ctx: Context): GPUShaderModule {\n    if (this._shaderModule) return this._shaderModule\n\n    return (this._shaderModule = ctx.device.createShaderModule({\n      code: shaderModuleCode,\n    }))\n  }\n\n  getRenderPipeline(ctx: Context): GPURenderPipeline {\n    if (this._renderPipeline) return this._renderPipeline\n\n    const vertexSource = this.getVertexSource()\n\n    return (this._renderPipeline = ctx.device.createRenderPipeline({\n      vertex: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"vertexRenderUV\",\n        buffers: [\n          {\n            arrayStride: vertexSource.vertexSourceStrideBytes(ctx),\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: vertexSource.vertexSourceXYZWOffsetBytes(ctx),\n                format: \"float32x4\" as GPUVertexFormat,\n              },\n              {\n                shaderLocation: 1,\n                offset: vertexSource.vertexSourceUVOffsetBytes(ctx),\n                format: \"float32x2\" as GPUVertexFormat,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"fragmentRenderUV\",\n        targets: [\n          {\n            // TODO: Remove this hard-coded value - get the real one somehow.\n            format: \"rgba8unorm\" as GPUTextureFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: \"triangle-list\",\n      },\n      layout: autoLayout(),\n    }))\n  }\n\n  getBindGroup(ctx: Context) {\n    if (this._bindGroup) return this._bindGroup\n\n    const sampler = ctx.device.createSampler({\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n    })\n\n    return (this._bindGroup = ctx.device.createBindGroup({\n      layout: this.getRenderPipeline(ctx).getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: sampler,\n        },\n        {\n          binding: 1,\n          resource: this.getTextureSource()\n            .textureSourceAsGPUTexture(ctx)\n            .createView(),\n        },\n      ],\n    }))\n  }\n\n  renderFrame(ctx: Context, frame: number, target: GPUTexture): void {\n    this.getTextureSource().textureSourceFrame(ctx, frame)\n    const vertexCount = this.getVertexSource().vertexSourceFrame(ctx, frame)\n\n    const passEncoder = ctx.commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: target.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: \"clear\" as GPULoadOp,\n          storeOp: \"store\" as GPUStoreOp,\n        },\n      ],\n    })\n    passEncoder.setPipeline(this.getRenderPipeline(ctx))\n    passEncoder.setVertexBuffer(\n      0,\n      this.getVertexSource().vertexSourceAsGPUBuffer(ctx)\n    )\n    passEncoder.setBindGroup(0, this.getBindGroup(ctx))\n    passEncoder.draw(vertexCount, 1, 0, 0)\n    passEncoder.end()\n  }\n}\n","export default \"@group(0) @binding(0) var use_sampler: sampler;\\n@group(0) @binding(1) var use_texture: texture_2d<f32>;\\n\\nstruct VertexOutput {\\n  @builtin(position) pos: vec4<f32>;\\n  @location(0) uv: vec2<f32>;\\n}\\n\\n@stage(vertex)\\nfn vertexRenderUV(\\n  @location(0) pos_in: vec4<f32>,\\n  @location(1) uv_in: vec2<f32>,\\n) ->\\n  VertexOutput\\n{\\n  var out: VertexOutput;\\n  out.pos = pos_in;\\n  out.uv = uv_in;\\n  return out;\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderUV(\\n  @location(0) uv_in : vec2<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return textureSample(use_texture, use_sampler, uv_in.xy);\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport VertexSource from \"./VertexSource\"\n\nexport default class VertexSourceRect implements VertexSource {\n  private _aspectFillRatio?: number\n\n  private _buffer?: GPUBuffer\n  private _bufferUpToDate = false\n\n  setAspectFillRatio(ratio: number) {\n    if (this._aspectFillRatio === ratio) return\n    this._aspectFillRatio = ratio\n    this._bufferUpToDate = false\n  }\n\n  private getBuffer(ctx: Context): GPUBuffer {\n    if (this._buffer) return this._buffer\n\n    const buffer = ctx.device.createBuffer({\n      size: this.vertexSourceTotalBytes(ctx),\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    })\n\n    return (this._buffer = buffer)\n  }\n\n  private updateBuffer(ctx: Context) {\n    if (this._bufferUpToDate) return\n\n    var uMin = 0\n    var uMax = 1\n    var vMin = 0\n    var vMax = 1\n\n    if (this._aspectFillRatio) {\n      if (this._aspectFillRatio < 1) {\n        vMin = 0.5 - 0.5 * this._aspectFillRatio\n        vMax = 1 - vMin\n      } else {\n        uMin = 0.5 - 0.5 / this._aspectFillRatio\n        uMax = 1 - uMin\n      }\n    }\n\n    // prettier-ignore\n    const data = new Float32Array([\n    // (x, y, z, w),  (u, v)\n        1, 1, 0, 1, uMax, vMin,\n       -1,-1, 0, 1, uMin, vMax,\n       -1, 1, 0, 1, uMin, vMin,\n        1, 1, 0, 1, uMax, vMin,\n        1,-1, 0, 1, uMax, vMax,\n       -1,-1, 0, 1, uMin, vMax,\n    ])\n\n    ctx.device.queue.writeBuffer(this.getBuffer(ctx), 0, data, 0, data.length)\n\n    this._bufferUpToDate = true\n  }\n\n  vertexSourceAsGPUBuffer(ctx: Context): GPUBuffer {\n    return this.getBuffer(ctx)\n  }\n\n  vertexSourceTotalBytes = (ctx: Context) => 6 * 6 * 4\n  vertexSourceStrideBytes = (ctx: Context) => 6 * 4\n  vertexSourceXYZWOffsetBytes = (ctx: Context) => 0\n  vertexSourceUVOffsetBytes = (ctx: Context) => 4 * 4\n\n  vertexSourceFrame(ctx: Context, frame: number) {\n    this.updateBuffer(ctx)\n    return 6\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport Render from \"./Render\"\nimport RenderUV from \"./RenderUV\"\nimport TextureSource from \"./TextureSource\"\nimport VertexSourceRect from \"./VertexSourceRect\"\n\nexport default class RenderTextureRect implements Render {\n  private _renderUV = new RenderUV()\n\n  constructor() {\n    this._renderUV.setVertexSource(new VertexSourceRect())\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._renderUV.setTextureSource(textureSource)\n  }\n\n  renderFrame(ctx: Context, frame: number, target: GPUTexture): void {\n    // TODO : Use the source texture and target texture aspect ratios\n    // instead of hard-coding a number here.\n    // This doesn't yet work on the latest version of chromium, because\n    // those chromium builds don't yet expose texture width and height.\n    ;(this._renderUV.getVertexSource() as VertexSourceRect).setAspectFillRatio(\n      850 / 1275\n    )\n    this._renderUV.renderFrame(ctx, frame, target)\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport Render from \"./Render\"\n\nexport default class OutputCanvas {\n  _canvasContext: GPUCanvasContext\n  _renders: Render[] = []\n\n  constructor(canvasContext: GPUCanvasContext) {\n    this._canvasContext = canvasContext\n  }\n\n  addRender(render: Render) {\n    if (this._renders.includes(render)) return\n    this._renders.push(render)\n  }\n\n  outputFrame(ctx: Context, frame: number) {\n    const target = this._canvasContext.getCurrentTexture()\n    this._renders.forEach((render) => {\n      render.renderFrame(ctx, frame, target)\n    })\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport runDemo from \"./common/runDemo\"\n\nimport TextureSourceBitmap from \"./gpu-fu/TextureSourceBitmap\"\nimport TextureFilterConvolve from \"./gpu-fu/TextureFilterConvolve\"\nimport RenderTextureRect from \"./gpu-fu/RenderTextureRect\"\nimport OutputCanvas from \"./gpu-fu/OutputCanvas\"\n\nrunDemo(async (device, canvasContext) => {\n  const textureSource = await TextureSourceBitmap.fromURL(\n    \"./assets/fireweed.jpg\",\n  )\n\n  const sobelHorizontal = new TextureFilterConvolve()\n  sobelHorizontal.setTextureSource(textureSource)\n  sobelHorizontal.setKernel3x3(\n    // Sobel Horizontal Kernel (with scaling and bias to center on gray)\n    [1, 2, 1],\n    [0, 0, 0],\n    [-1, -2, -1],\n    { scale: 0.5, bias: 0.5 },\n  )\n\n  const renderUV = new RenderTextureRect()\n  renderUV.setTextureSource(sobelHorizontal)\n\n  const output = new OutputCanvas(canvasContext)\n  output.addRender(renderUV)\n\n  console.log(canvasContext.getCurrentTexture())\n\n  return function frame(ctx, frame) {\n    output.outputFrame(ctx, frame)\n  }\n})\n"],"names":["root","factory","exports","module","define","amd","self","this","Symbol","toStringTag","Object","defineProperty","value","getDevice","powerPreference","navigator","gpu","Error","requestAdapter","requestDevice","getCanvasContext","querySelector","device","canvas","document","canvasContext","getContext","configure","format","getPreferredCanvasFormat","alphaMode","bind","imageBitmap","label","_imageBitmap","_label","fromURL","url","img","createElement","src","decode","createImageBitmap","TextureSourceBitmap","textureSourceAsGPUTexture","ctx","_texture","createTexture","size","width","height","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","queue","copyExternalImageToTexture","source","texture","console","log","textureSourceFrame","frame","_kernelBufferUpToDate","getKernelData","_kernelData","setKernel3x3","row0","row1","row2","opts","scale","normalize","sum","reduce","accum","n","map","kernelData","Float32Array","bias","set","byteLength","_kernelBuffer","undefined","_shaderModule","_computePipeline","_bindGroup","getTextureSource","_textureSource","setTextureSource","textureSource","getKernelBuffer","buffer","createBuffer","GPUBufferUsage","UNIFORM","updateKernelBuffer","data","writeBuffer","length","getShaderModule","createShaderModule","code","getComputePipeline","createComputePipeline","compute","entryPoint","layout","autoLayout","getBindGroup","createSampler","magFilter","minFilter","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","STORAGE_BINDING","passEncoder","commandEncoder","beginComputePass","setPipeline","setBindGroup","dispatch","end","getVertexSource","_vertexSource","setVertexSource","vertexSource","_renderPipeline","getRenderPipeline","createRenderPipeline","vertex","buffers","arrayStride","vertexSourceStrideBytes","attributes","shaderLocation","offset","vertexSourceXYZWOffsetBytes","vertexSourceUVOffsetBytes","fragment","targets","primitive","topology","sampler","renderFrame","target","vertexCount","vertexSourceFrame","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setVertexBuffer","vertexSourceAsGPUBuffer","draw","_bufferUpToDate","vertexSourceTotalBytes","setAspectFillRatio","ratio","_aspectFillRatio","getBuffer","_buffer","VERTEX","updateBuffer","uMin","uMax","vMin","vMax","_renderUV","_renders","_canvasContext","addRender","render","includes","push","outputFrame","getCurrentTexture","forEach","setupFn","repeatFrameWithContext","frameFn","createCommandEncoder","submit","finish","runFrameWithContext","requestAnimationFrame","error","innerHTML","runDemo","sobelHorizontal","renderUV","output"],"sourceRoot":""}