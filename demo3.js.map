{"version":3,"file":"demo3.js","mappings":"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","sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/../gpu-fu/src/hooks.ts","webpack://beta/webpack/runtime/make namespace object","webpack://beta/../incubator/src/OutputCanvas.ts","webpack://beta/../incubator/src/VertexSourceRect.ts","webpack://beta/../incubator/src/RenderTextureRect.ts","webpack://beta/../incubator/src/RenderUV.ts","webpack://beta/../incubator/src/RenderUV.wgsl","webpack://beta/../incubator/src/TextureFilterConvolve.ts","webpack://beta/../incubator/src/TextureFilterConvolve3x3.wgsl","webpack://beta/../incubator/src/TextureSourceBitmapFromURL.ts","webpack://beta/../incubator/src/TextureSourceBitmap.ts","webpack://beta/../incubator/src/VertexSourceIcosahedron.ts","webpack://beta/../gpu-fu/src/Property.ts","webpack://beta/../gpu-fu/src/Derived.ts","webpack://beta/../gpu-fu/src/Operation.ts","webpack://beta/../gpu-fu/src/Effect.ts","webpack://beta/../gpu-fu/src/Context.ts","webpack://beta/./src/runDemo.ts","webpack://beta/./src/demo3.ts","webpack://beta/../gpu-fu/src/Unit.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","import {\n  Context,\n  ContextForGPUResource,\n  ContextForGPUAction,\n  MaybeDestroyableGPUResource,\n  ContextEmpty,\n  ContextImplementation,\n} from \"./Context\"\nimport { Unit, UnitFn } from \"./Unit\"\nimport { Property, PropertyImplementation, PropertyReadOnly } from \"./Property\"\n\nexport function useProp<T>(ctx: Context): Property<T | undefined> {\n  return ctx._useProp<T | undefined>(undefined) as Property<T | undefined>\n}\n\nexport function useInitializedProp<T>(\n  ctx: Context,\n  initialValue: (() => T) | T,\n): Property<T> {\n  return ctx._useProp<T>(initialValue)\n}\n\nexport function useUnit<U>(ctx: Context, unitFn: UnitFn<U>): Unit<U> {\n  const unitProp = ctx._useProp<Unit<U>>(() => ({\n    ...unitFn(ctx),\n    _ctx: ctx as ContextImplementation,\n  }))\n\n  return (unitProp as PropertyImplementation<Unit<U>>)._current\n}\n\nexport function useGPUResource<T extends MaybeDestroyableGPUResource>(\n  ctx: Context,\n  create: (ctx: ContextForGPUResource) => T,\n): PropertyReadOnly<T> {\n  return ctx._useGPUResource<T>(create)\n}\n\nexport function useGPUUpdate(\n  producedProps: PropertyReadOnly<unknown>[],\n  ctx: Context,\n  action: (ctx: ContextForGPUAction) => void,\n): void {\n  ctx._useGPUUpdate(producedProps, action)\n}\n\nexport function useEffect(\n  ctx: Context,\n  effect: (ctx: ContextEmpty) => (() => void) | undefined,\n) {\n  return ctx._useEffect(effect)\n}\n\nexport function useDerived<T>(\n  ctx: Context,\n  create: (ctx: ContextEmpty) => T,\n): PropertyReadOnly<T> {\n  return ctx._useDerived<T>(create)\n}\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference types=\"@webgpu/types\" />\n\nimport { Render, UnitRoot } from \"@gpu-fu/gpu-fu\"\n\nexport default class OutputCanvas {\n  _canvasContext: GPUCanvasContext\n  _renders: UnitRoot<Render>[] = []\n\n  constructor(canvasContext: GPUCanvasContext) {\n    this._canvasContext = canvasContext\n  }\n\n  addRender(render: UnitRoot<Render>) {\n    if (this._renders.includes(render)) return\n    this._renders.push(render)\n  }\n\n  outputFrame(commandEncoder: GPUCommandEncoder) {\n    const target = this._canvasContext.getCurrentTexture()\n\n    // TODO: remove this polyfill when Chromium is working properly.\n    // Current versions of Chromium on Linux leave these properties undefined,\n    // even though the type declarations say they are mandatory properties.\n    ;(target as any).width = (this._canvasContext.canvas as any).width\n    ;(target as any).height = (this._canvasContext.canvas as any).height\n    ;(target as any).format = \"rgba8unorm\"\n\n    this._renders.forEach((render) => {\n      render.renderTarget.setAndNotify(target)\n      render.runFrame(commandEncoder, [render.renderTarget])\n    })\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  Context,\n  useProp,\n  useGPUUpdate,\n  useGPUResource,\n  VertexBufferLayout,\n} from \"@gpu-fu/gpu-fu\"\n\nconst resultVertexCount = 6\nconst resultVertexBufferLayout: VertexBufferLayout = {\n  xyzwOffsetBytes: 0,\n  uvOffsetBytes: 4 * Float32Array.BYTES_PER_ELEMENT,\n  strideBytes: 6 * Float32Array.BYTES_PER_ELEMENT,\n}\n\nexport default function VertexSourceRect(ctx: Context) {\n  const aspectFillRatio = useProp<number>(ctx)\n\n  const resultVertexBuffer = useGPUResource(ctx, (ctx) =>\n    ctx.device.createBuffer({\n      size: resultVertexCount * resultVertexBufferLayout.strideBytes,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    }),\n  )\n\n  useGPUUpdate([resultVertexBuffer], ctx, (ctx) => {\n    if (!resultVertexBuffer.current) return\n\n    var uMin = 0\n    var uMax = 1\n    var vMin = 0\n    var vMax = 1\n\n    if (aspectFillRatio.current) {\n      if (aspectFillRatio.current < 1) {\n        vMin = 0.5 - 0.5 * aspectFillRatio.current\n        vMax = 1 - vMin\n      } else {\n        uMin = 0.5 - 0.5 / aspectFillRatio.current\n        uMax = 1 - uMin\n      }\n    }\n\n    // prettier-ignore\n    const data = new Float32Array([\n      // (x, y, z, w),  (u, v)\n          1, 1, 0, 1, uMax, vMin,\n         -1,-1, 0, 1, uMin, vMax,\n         -1, 1, 0, 1, uMin, vMin,\n          1, 1, 0, 1, uMax, vMin,\n          1,-1, 0, 1, uMax, vMax,\n         -1,-1, 0, 1, uMin, vMax,\n      ])\n\n    ctx.device.queue.writeBuffer(\n      resultVertexBuffer.current,\n      0,\n      data,\n      0,\n      data.length,\n    )\n  })\n\n  return {\n    aspectFillRatio,\n    resultVertexBuffer,\n    resultVertexBufferLayout,\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, useDerived, useUnit } from \"@gpu-fu/gpu-fu\"\nimport RenderUV from \"./RenderUV\"\nimport VertexSourceRect from \"./VertexSourceRect\"\n\nexport default function RenderTextureRect(ctx: Context) {\n  const { textureSource, vertexBuffer, vertexBufferLayout, renderTarget } =\n    RenderUV(ctx)\n\n  const rect = useUnit(ctx, VertexSourceRect)\n  vertexBuffer.setFrom(rect.resultVertexBuffer)\n  vertexBufferLayout.set(rect.resultVertexBufferLayout)\n\n  // Determine the aspect ratio to fill based on the input and output sizes.\n  const aspectFillRatio = useDerived(ctx, (ctx) => {\n    if (!textureSource.current) return\n    if (!renderTarget.current) return\n\n    return (\n      (textureSource.current.width * renderTarget.current.height) /\n      (textureSource.current.height * renderTarget.current.width)\n    )\n  })\n  rect.aspectFillRatio.setFrom(aspectFillRatio)\n\n  return { textureSource, renderTarget }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  Context,\n  useProp,\n  useGPUResource,\n  useGPUUpdate,\n  VertexBufferLayout,\n} from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode from \"./RenderUV.wgsl\"\n\nexport default function RenderUV(ctx: Context) {\n  const cameraMatrixBuffer = useProp<GPUBuffer>(ctx)\n  const vertexBuffer = useProp<GPUBuffer>(ctx)\n  const vertexBufferLayout = useProp<VertexBufferLayout>(ctx)\n  const textureSource = useProp<GPUTexture>(ctx)\n  const renderTarget = useProp<GPUTexture>(ctx)\n\n  const shaderModule = useGPUResource(ctx, (ctx) =>\n    ctx.device.createShaderModule({\n      code: shaderModuleCode,\n    }),\n  )\n\n  const renderPipeline = useGPUResource(ctx, (ctx) => {\n    if (!vertexBufferLayout.current) return\n    if (!renderTarget.current) return\n\n    return ctx.device.createRenderPipeline({\n      layout: \"auto\",\n      primitive: {\n        topology: \"triangle-list\",\n        // TODO: Configurable `cullMode`\n      },\n      vertex: {\n        module: shaderModule.current,\n        entryPoint: cameraMatrixBuffer.current\n          ? \"vertexRenderUVWithMatrix\"\n          : \"vertexRenderUV\",\n        buffers: [\n          {\n            arrayStride: vertexBufferLayout.current.strideBytes,\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: vertexBufferLayout.current.xyzwOffsetBytes,\n                format: \"float32x4\" as GPUVertexFormat,\n              },\n              {\n                shaderLocation: 1,\n                offset: vertexBufferLayout.current.uvOffsetBytes,\n                format: \"float32x2\" as GPUVertexFormat,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: shaderModule.current,\n        entryPoint: \"fragmentRenderUV\",\n        targets: [{ format: renderTarget.current.format }],\n      },\n      depthStencil: {\n        depthWriteEnabled: true,\n        depthCompare: \"less\",\n        format: \"depth24plus\",\n      },\n    })\n  })\n\n  const sampler = useGPUResource(ctx, (ctx) =>\n    ctx.device.createSampler({\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n    }),\n  )\n\n  const bindGroup = useGPUResource(ctx, (ctx) => {\n    if (!renderPipeline.current) return\n    if (!textureSource.current) return\n\n    const entries: GPUBindGroupEntry[] = [\n      {\n        binding: 1,\n        resource: sampler.current,\n      },\n      {\n        binding: 2,\n        resource: textureSource.current.createView(),\n      },\n    ]\n    if (cameraMatrixBuffer.current)\n      entries.unshift({\n        binding: 0,\n        resource: { buffer: cameraMatrixBuffer.current },\n      })\n\n    return ctx.device.createBindGroup({\n      layout: renderPipeline.current.getBindGroupLayout(0),\n      entries,\n    })\n  })\n\n  const depthStencil = useGPUResource(ctx, (ctx) => {\n    if (!renderTarget.current) return\n\n    return ctx.device.createTexture({\n      size: {\n        width: renderTarget.current.width,\n        height: renderTarget.current.height,\n      },\n      format: \"depth24plus\",\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    })\n  })\n\n  useGPUUpdate([renderTarget], ctx, (ctx) => {\n    if (!vertexBuffer.current) return\n    if (!vertexBufferLayout.current) return\n    if (!renderTarget.current) return\n    if (!depthStencil.current) return\n    if (!renderPipeline.current) return\n    if (!bindGroup.current) return\n    const vertexCount =\n      vertexBuffer.current.size / vertexBufferLayout.current.strideBytes\n\n    const passEncoder = ctx.commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.current.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: \"clear\" as GPULoadOp,\n          storeOp: \"store\" as GPUStoreOp,\n        },\n      ],\n      depthStencilAttachment: {\n        view: depthStencil.current.createView(),\n        depthClearValue: 1.0,\n        depthLoadOp: \"clear\" as GPULoadOp,\n        depthStoreOp: \"store\" as GPUStoreOp,\n      },\n    })\n    passEncoder.setPipeline(renderPipeline.current)\n    passEncoder.setVertexBuffer(0, vertexBuffer.current)\n    passEncoder.setBindGroup(0, bindGroup.current)\n    passEncoder.draw(vertexCount, 1, 0, 0)\n    passEncoder.end()\n  })\n\n  return {\n    cameraMatrixBuffer,\n    textureSource,\n    vertexBuffer,\n    vertexBufferLayout,\n    renderTarget,\n  }\n}\n","export default \"@group(0) @binding(0) var<uniform> use_matrix: mat4x4<f32>;\\n@group(0) @binding(1) var use_sampler: sampler;\\n@group(0) @binding(2) var use_texture: texture_2d<f32>;\\n\\nstruct VertexOutput {\\n  @builtin(position) pos: vec4<f32>,\\n  @location(0) uv: vec2<f32>,\\n}\\n\\n@stage(vertex)\\nfn vertexRenderUV(\\n  @location(0) pos_in: vec4<f32>,\\n  @location(1) uv_in: vec2<f32>,\\n) ->\\n  VertexOutput\\n{\\n  var out: VertexOutput;\\n  out.pos = pos_in;\\n  out.uv = uv_in;\\n  return out;\\n}\\n\\n@stage(vertex)\\nfn vertexRenderUVWithMatrix(\\n  @location(0) pos_in: vec4<f32>,\\n  @location(1) uv_in: vec2<f32>,\\n) ->\\n  VertexOutput\\n{\\n  var out: VertexOutput;\\n  out.pos = use_matrix * pos_in;\\n  out.uv = uv_in;\\n  return out;\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderUV(\\n  @location(0) uv_in : vec2<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return textureSample(use_texture, use_sampler, uv_in.xy);\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, useGPUResource, useProp, useGPUUpdate } from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode3x3 from \"./TextureFilterConvolve3x3.wgsl\"\n\ninterface SetKernelOptions {\n  bias?: number\n  scale?: number\n  normalize?: boolean\n}\n\nexport default function TextureFilterConvolve(ctx: Context) {\n  const textureSource = useProp<GPUTexture>(ctx)\n  const kernelData = useProp<Float32Array>(ctx)\n\n  function setKernel3x3(\n    row0: [number, number, number],\n    row1: [number, number, number],\n    row2: [number, number, number],\n    opts: SetKernelOptions = {},\n  ) {\n    // Respect scale and/or normalize options if present.\n    if (opts.scale || opts.normalize) {\n      var scale = opts.scale ?? 1\n      if (opts.normalize) {\n        var sum = 0\n        sum = row0.reduce((accum, n) => accum + n, sum)\n        sum = row1.reduce((accum, n) => accum + n, sum)\n        sum = row2.reduce((accum, n) => accum + n, sum)\n        if (sum !== 0) scale = scale / sum\n      }\n      if (scale !== 1) {\n        row0 = row0.map((n) => n * scale) as typeof row0\n        row1 = row1.map((n) => n * scale) as typeof row1\n        row2 = row2.map((n) => n * scale) as typeof row2\n      }\n    }\n\n    const newKernelData = new Float32Array(10)\n    newKernelData[0] = opts.bias ?? 0\n    newKernelData.set(row0, 1)\n    newKernelData.set(row1, 4)\n    newKernelData.set(row2, 7)\n    kernelData.set(newKernelData)\n  }\n\n  const kernelBuffer = useGPUResource(\n    ctx,\n    (ctx) =>\n      kernelData.current?.byteLength &&\n      ctx.device.createBuffer({\n        size: kernelData.current?.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      }),\n  )\n\n  useGPUUpdate([kernelBuffer], ctx, (ctx) => {\n    if (!kernelBuffer.current) return\n    if (!kernelData.current) return\n\n    ctx.device.queue.writeBuffer(\n      kernelBuffer.current,\n      0,\n      kernelData.current,\n      0,\n      kernelData.current.length,\n    )\n  })\n\n  const computePipeline = useGPUResource(ctx, (ctx) => {\n    let shaderModuleCode: string\n    switch (kernelData.current?.length) {\n      case 10:\n        shaderModuleCode = shaderModuleCode3x3\n        break\n      default:\n        return\n    }\n\n    return ctx.device.createComputePipeline({\n      layout: \"auto\",\n      compute: {\n        module: ctx.device.createShaderModule({\n          code: shaderModuleCode,\n        }),\n        entryPoint: \"computeTextureFilterConvolve3x3\",\n      },\n    })\n  })\n\n  const resultTexture = useGPUResource(ctx, (ctx) => {\n    if (!textureSource.current) return\n\n    return ctx.device.createTexture({\n      format: \"rgba8unorm\",\n      size: {\n        width: textureSource.current.width,\n        height: textureSource.current.height,\n      },\n      usage:\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.STORAGE_BINDING |\n        GPUTextureUsage.TEXTURE_BINDING,\n    })\n  })\n\n  const bindGroup = useGPUResource(\n    ctx,\n    (ctx) =>\n      computePipeline.current &&\n      kernelBuffer.current &&\n      textureSource.current &&\n      resultTexture.current &&\n      ctx.device.createBindGroup({\n        layout: computePipeline.current.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: { buffer: kernelBuffer.current },\n          },\n          {\n            binding: 1,\n            resource: textureSource.current.createView(),\n          },\n          {\n            binding: 2,\n            resource: resultTexture.current.createView(),\n          },\n        ],\n      }),\n  )\n\n  useGPUUpdate([resultTexture], ctx, (ctx) => {\n    if (!textureSource.current) return\n    if (!computePipeline.current) return\n    if (!bindGroup.current) return\n\n    const workGroupSizeX = 32 // (must match the WGSL code)\n    const workGroupSizeY = 1 // (must match the WGSL code)\n\n    const passEncoder = ctx.commandEncoder.beginComputePass()\n    passEncoder.setPipeline(computePipeline.current)\n    passEncoder.setBindGroup(0, bindGroup.current)\n    passEncoder.dispatchWorkgroups(\n      textureSource.current.width / workGroupSizeX,\n      textureSource.current.height / workGroupSizeY,\n    )\n    passEncoder.end()\n  })\n\n  return {\n    textureSource,\n    setKernel3x3,\n    resultTexture,\n  }\n}\n","export default \"@group(0) @binding(0) var<uniform> kernel_3x3: Kernel3x3;\\n@group(0) @binding(1) var texture_in: texture_2d<f32>;\\n@group(0) @binding(2) var texture_out: texture_storage_2d<rgba8unorm, write>;\\n\\nstruct Kernel3x3 {\\n  bias: f32,\\n  aa: f32,\\n  ba: f32,\\n  ca: f32,\\n  ab: f32,\\n  bb: f32,\\n  cb: f32,\\n  ac: f32,\\n  bc: f32,\\n  cc: f32,\\n}\\n\\n// TODO: What is the most likely optimal workgroup size?\\n@stage(compute) @workgroup_size(32, 1, 1)\\nfn computeTextureFilterConvolve3x3(\\n  @builtin(global_invocation_id) global_id: vec3<u32>,\\n) {\\n  let b = vec2<i32>(global_id.xy);\\n  let a = max(b - 1, vec2<i32>(0));\\n  let c = min(b + 1, min(\\n    textureDimensions(texture_in),\\n    textureDimensions(texture_out),\\n  ));\\n\\n  var sum = vec4<f32>(kernel_3x3.bias);\\n\\n  sum = sum + kernel_3x3.aa * textureLoad(texture_in, vec2<i32>(a.x, a.y), 0);\\n  sum = sum + kernel_3x3.ba * textureLoad(texture_in, vec2<i32>(b.x, a.y), 0);\\n  sum = sum + kernel_3x3.ca * textureLoad(texture_in, vec2<i32>(c.x, a.y), 0);\\n\\n  sum = sum + kernel_3x3.ab * textureLoad(texture_in, vec2<i32>(a.x, b.y), 0);\\n  sum = sum + kernel_3x3.bb * textureLoad(texture_in, vec2<i32>(b.x, b.y), 0);\\n  sum = sum + kernel_3x3.cb * textureLoad(texture_in, vec2<i32>(c.x, b.y), 0);\\n\\n  sum = sum + kernel_3x3.ac * textureLoad(texture_in, vec2<i32>(a.x, c.y), 0);\\n  sum = sum + kernel_3x3.bc * textureLoad(texture_in, vec2<i32>(b.x, c.y), 0);\\n  sum = sum + kernel_3x3.cc * textureLoad(texture_in, vec2<i32>(c.x, c.y), 0);\\n\\n  textureStore(texture_out, b, sum);\\n}\\n\";","import { Context, useEffect } from \"@gpu-fu/gpu-fu\"\nimport TextureSourceBitmap from \"./TextureSourceBitmap\"\n\nexport default function TextureSourceBitmapFromURL(ctx: Context) {\n  const { imageBitmap, label, resultTexture } = TextureSourceBitmap(ctx)\n\n  // Use the existing label property for a dual-purpose.\n  // We use it as the URL to fetch from (though this implies\n  // the assumption that the label will always be equal to the URL).\n  const url = label\n\n  useEffect(ctx, (ctx) => {\n    const currentURL = url.current\n    if (!currentURL) return () => {}\n\n    var cancelled = false\n\n    const img = document.createElement(\"img\")\n    img.src = currentURL\n    img\n      .decode()\n      .then(() => (cancelled ? undefined : createImageBitmap(img)))\n      .then((newImageBitmap) => {\n        if (!cancelled && newImageBitmap) imageBitmap.set(newImageBitmap)\n      })\n      .catch(console.error)\n\n    return () => {\n      cancelled = true\n    }\n  })\n\n  return {\n    url,\n    resultTexture,\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, useProp, useGPUResource, useGPUUpdate } from \"@gpu-fu/gpu-fu\"\n\nexport default function TextureSourceBitmap(ctx: Context) {\n  const imageBitmap = useProp<ImageBitmap>(ctx)\n  const label = useProp<string>(ctx)\n\n  const texture = useGPUResource(ctx, (ctx) => {\n    if (!imageBitmap.current) return\n\n    return ctx.device.createTexture({\n      label: label.current,\n      size: {\n        width: imageBitmap.current.width,\n        height: imageBitmap.current.height,\n      },\n      format: \"rgba8unorm\",\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    })\n  })\n\n  useGPUUpdate([texture], ctx, (ctx) => {\n    if (!imageBitmap.current) return\n    if (!texture.current) return\n\n    ctx.device.queue.copyExternalImageToTexture(\n      { source: imageBitmap.current },\n      { texture: texture.current },\n      {\n        width: imageBitmap.current.width,\n        height: imageBitmap.current.height,\n      },\n    )\n  })\n\n  return {\n    imageBitmap,\n    label,\n    resultTexture: texture,\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  Context,\n  useGPUResource,\n  useGPUUpdate,\n  VertexBufferLayout,\n} from \"@gpu-fu/gpu-fu\"\n\nconst resultVertexCount = 60\nconst resultVertexBufferLayout: VertexBufferLayout = {\n  xyzwOffsetBytes: 0,\n  uvOffsetBytes: 4 * Float32Array.BYTES_PER_ELEMENT,\n  strideBytes: 6 * Float32Array.BYTES_PER_ELEMENT,\n}\n\nexport default function VertexSourceIcosahedron(ctx: Context) {\n  const resultVertexBuffer = useGPUResource(ctx, (ctx) =>\n    ctx.device.createBuffer({\n      size: resultVertexCount * resultVertexBufferLayout.strideBytes,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    }),\n  )\n\n  useGPUUpdate([resultVertexBuffer], ctx, (ctx) => {\n    if (!resultVertexBuffer.current) return\n\n    var uMin = 0\n    var uMax = 1\n    var vMin = 0\n    var vMax = 1\n\n    const t = (1 + Math.sqrt(5)) / 2\n\n    // prettier-ignore\n    const data = new Float32Array([\n    // (x, y, z, w),  (u, v)\n        t, 1, 0, 1, uMax, vMin, // v0\n        0, t, 1, 1, uMax, vMax, // v8\n        1, 0, t, 1, uMin, vMax, // v4\n\n        t, 1, 0, 1, uMax, vMin, // v0\n        1, 0, t, 1, uMax, vMax, // v4\n        t,-1, 0, 1, uMin, vMax, // v2\n\n        t, 1, 0, 1, uMax, vMin, // v0\n        t,-1, 0, 1, uMax, vMax, // v2\n        1, 0,-t, 1, uMin, vMax, // v5\n\n        t, 1, 0, 1, uMax, vMin, // v0\n        1, 0,-t, 1, uMax, vMax, // v5\n        0, t,-1, 1, uMin, vMax, // v10\n\n        t, 1, 0, 1, uMax, vMin, // v0\n        0, t,-1, 1, uMax, vMax, // v10\n        0, t, 1, 1, uMin, vMax, // v8\n\n       -1, 0, t, 1, uMax, vMin, // v1\n        1, 0, t, 1, uMax, vMax, // v4\n        0, t, 1, 1, uMin, vMax, // v8\n\n        0,-t, 1, 1, uMax, vMin, // v6\n        t,-1, 0, 1, uMax, vMax, // v2\n        1, 0, t, 1, uMin, vMax, // v4\n\n        0,-t,-1, 1, uMax, vMin, // v9\n        1, 0,-t, 1, uMax, vMax, // v5\n        t,-1, 0, 1, uMin, vMax, // v2\n\n       -1, 0,-t, 1, uMax, vMin, // v11\n        0, t,-1, 1, uMax, vMax, // v10\n        1, 0,-t, 1, uMin, vMax, // v5\n\n       -t, 1, 0, 1, uMax, vMin, // v7\n        0, t, 1, 1, uMax, vMax, // v8\n        0, t,-1, 1, uMin, vMax, // v10\n\n        1, 0, t, 1, uMax, vMin, // v4\n       -1, 0, t, 1, uMax, vMax, // v1\n        0,-t, 1, 1, uMin, vMax, // v6\n\n        t,-1, 0, 1, uMax, vMin, // v2\n        0,-t, 1, 1, uMax, vMax, // v6\n        0,-t,-1, 1, uMin, vMax, // v9\n\n        1, 0,-t, 1, uMax, vMin, // v5\n        0,-t,-1, 1, uMax, vMax, // v9\n       -1, 0,-t, 1, uMin, vMax, // v11\n\n        0, t,-1, 1, uMax, vMin, // v10\n       -1, 0,-t, 1, uMax, vMax, // v11\n       -t, 1, 0, 1, uMin, vMax, // v7\n\n        0, t, 1, 1, uMax, vMin, // v8\n       -t, 1, 0, 1, uMax, vMax, // v7\n       -1, 0, t, 1, uMin, vMax, // v1\n\n       -t,-1, 0, 1, uMax, vMin, // v3\n        0,-t, 1, 1, uMax, vMax, // v6\n       -1, 0, t, 1, uMin, vMax, // v1\n\n       -t,-1, 0, 1, uMax, vMin, // v3\n        0,-t,-1, 1, uMax, vMax, // v9\n        0,-t, 1, 1, uMin, vMax, // v6\n\n       -t,-1, 0, 1, uMax, vMin, // v3\n       -1, 0,-t, 1, uMax, vMax, // v11\n        0,-t,-1, 1, uMin, vMax, // v9\n\n       -t,-1, 0, 1, uMax, vMin, // v3\n       -t, 1, 0, 1, uMax, vMax, // v7\n       -1, 0,-t, 1, uMin, vMax, // v11\n\n       -t,-1, 0, 1, uMax, vMin, // v3\n       -1, 0, t, 1, uMax, vMax, // v1\n       -t, 1, 0, 1, uMin, vMax, // v7\n      ])\n\n    ctx.device.queue.writeBuffer(\n      resultVertexBuffer.current,\n      0,\n      data,\n      0,\n      data.length,\n    )\n  })\n\n  return {\n    resultVertexBuffer,\n    resultVertexBufferLayout,\n  }\n}\n","import { ContextImplementation } from \"./Context\"\nimport { Operation } from \"./Operation\"\n\nexport type Property<T> = Pick<\n  PropertyImplementation<T>,\n  | \"current\"\n  | \"getNonReactively\"\n  | \"readOnly\"\n  | \"setFrom\"\n  | \"set\"\n  | \"setAndNotify\"\n  | \"change\"\n  | \"mutate\"\n  | \"_runIfNeededAt\"\n  | \"_produceIfNeededAt\"\n  | \"_attachProducerOperation\"\n>\n\nexport type PropertyReadOnly<T> = Pick<\n  PropertyImplementation<T>,\n  | \"current\"\n  | \"getNonReactively\"\n  | \"_runIfNeededAt\"\n  | \"_produceIfNeededAt\"\n  | \"_attachProducerOperation\"\n>\n\nexport class PropertyImplementation<T> implements Property<T> {\n  private _ctx: ContextImplementation\n  _current: T // TODO: private\n  private _next: T\n  private _changeAtNextTick = false\n  private _changedClockNumber = 0\n  private _producedClockNumber = 0\n  private _producerOperations: Operation[] = []\n  private _readingFrom?: PropertyReadOnly<T>\n\n  constructor(initialValue: T, ctx: ContextImplementation) {\n    this._current = initialValue\n    this._next = initialValue\n    this._ctx = ctx\n  }\n\n  _attachProducerOperation(op: Operation): void {\n    this._producerOperations.push(op)\n  }\n\n  _runIfNeededAt(clockNumber: number): boolean {\n    const readingFrom = this._readingFrom\n    if (readingFrom && !this._changeAtNextTick)\n      return readingFrom._runIfNeededAt(clockNumber)\n\n    if (!this._changeAtNextTick) return this._changedClockNumber >= clockNumber\n\n    delete this._readingFrom\n    this._current = this._next\n    this._changeAtNextTick = false\n    this._changedClockNumber = clockNumber\n\n    return true\n  }\n\n  _produceIfNeededAt(clockNumber: number): boolean {\n    if (this._producedClockNumber >= clockNumber) return true\n\n    var depsChanged = false\n    if (this._readingFrom?._produceIfNeededAt(clockNumber)) depsChanged = true\n    this._producerOperations.forEach((op) => {\n      if (op._produceIfNeededAt(clockNumber)) depsChanged = true\n    })\n\n    if (\n      !depsChanged &&\n      this._changedClockNumber < clockNumber &&\n      this._producedClockNumber > 0\n    )\n      return false\n\n    this._producedClockNumber = clockNumber\n    return true\n  }\n\n  // Get the current value of the property.\n  //\n  // This can only be accessed from within a reactive context,\n  // since it implies that you want to track the property as a dependency\n  // dependency that will cause the reactive context to be called again.\n  // To get the current value non-reactively, call `getNonReactively` instead.\n  get current(): T {\n    const currentAction = this._ctx._currentAction\n    if (!currentAction)\n      throw new Error(\n        \"It's only possible to read properties from within a reactive context\",\n      )\n    currentAction._attachDependency(this)\n\n    const readingFrom = this._readingFrom\n    if (readingFrom) return readingFrom.current\n\n    return this._current\n  }\n\n  // Get the current value of the property without dependency tracking.\n  // Unlike the `current` getter, this can be called anywhere,\n  // both in contexts which are reactive and non-reactive.\n  // But if called in a reactive context, there is no dependency link created.\n  getNonReactively(): T {\n    const readingFrom = this._readingFrom\n    if (readingFrom) return readingFrom.getNonReactively()\n\n    return this._current\n  }\n\n  // Get a version of this property accessor that can only read (in TypeScript).\n  get readOnly(): PropertyReadOnly<T> {\n    return this\n  }\n\n  // TODO: Document\n  setFrom(other: PropertyReadOnly<T>) {\n    this._readingFrom = other\n  }\n\n  // Assign a new value to the property, notifying any reactive effects if\n  // (and only if) the new value is not referentially identical to the old one.\n  //\n  // Use `setAndNotify` instead if you want to unconditionally notify all\n  // downstream reactive effects even if the new value is the same.\n  set(newValue: T) {\n    if (this._current !== newValue) {\n      this._next = newValue\n      this.notify()\n    }\n  }\n\n  // Assign a new value to the property, notifying all reactive effects,\n  // regardless of whether the new value is referentially identical to the old.\n  //\n  // Usually you want to use `set` instead, which checks referential identity.\n  setAndNotify(newValue: T) {\n    this._next = newValue\n    this.notify()\n  }\n\n  // Use a function to change the value of the property based on the current\n  // value (which will be passed as the argument to the function).\n  //\n  // All reactive effects will be notified if (and only if) the new value\n  // produced by the function is not referentially identical to the old value.\n  //\n  // Use `mutate` instead if the value is an object type that you want to mutate\n  // to change it and trigger reactive effects without actually having to\n  // produce a new referentially new object for the new value.\n  change(fn: (currentValue: T) => T) {\n    if (this._readingFrom)\n      throw new Error(\n        \"changing a property that was set from another property is not yet supported\",\n      )\n    this.set(fn(this._current))\n  }\n\n  // Use a function to mutate the current value of the property,\n  // without changing its referential identity.\n  //\n  // All reactive effects will be notified regardless of what the function does.\n  mutate(fn: (currentValue: T) => unknown) {\n    if (this._readingFrom)\n      throw new Error(\n        \"mutating a property that was set from another property is not yet supported\",\n      )\n    fn(this._current)\n    this.notify() // assume mutation always happens\n  }\n\n  private notify() {\n    this._changeAtNextTick = true\n  }\n}\n","import { ContextImplementation } from \"./Context\"\nimport { Operation } from \"./Operation\"\nimport { PropertyReadOnly } from \"./Property\"\n\nexport type Derived<T> = PropertyReadOnly<T>\n\nexport class DerivedImplementation<T> implements Derived<T> {\n  _ctx: ContextImplementation\n  _fn: (ctx: unknown) => T\n  _deps = new Set<PropertyReadOnly<unknown>>()\n  _cachedResult?: T\n  _cachedClockNumber: number = 0\n  _producedClockNumber = 0\n  _producerOperations: Operation[] = []\n\n  constructor(ctx: ContextImplementation, fn: (ctx: unknown) => T) {\n    this._ctx = ctx\n    this._fn = fn\n  }\n\n  _attachDependency(dep: PropertyReadOnly<unknown>): void {\n    this._deps.add(dep)\n  }\n\n  _attachProducerOperation(op: Operation): void {\n    this._producerOperations.push(op)\n  }\n\n  _runIfNeededAt(clockNumber: number): boolean {\n    if (this._cachedClockNumber >= clockNumber) return true\n\n    var depsChanged = false\n    this._deps.forEach((dep) => {\n      if (dep._runIfNeededAt(clockNumber)) depsChanged = true\n    })\n    if (!depsChanged && this._cachedClockNumber > 0) return false\n\n    const outerAction = this._ctx._currentAction\n    this._ctx._currentAction = this\n\n    // Run the destroy method of the previous result to clean up if applicable.\n    const previousResult = this._cachedResult\n    if (\n      typeof previousResult === \"object\" &&\n      \"destroy\" in previousResult &&\n      typeof (previousResult as any).destroy === \"function\"\n    ) {\n      ;(previousResult as any).destroy()\n    }\n\n    this._cachedResult = this._fn(this._ctx)\n    this._cachedClockNumber = clockNumber\n\n    this._ctx._currentAction = outerAction\n\n    return true\n  }\n\n  _produceIfNeededAt(clockNumber: number) {\n    if (this._producedClockNumber >= clockNumber) return true\n\n    var depsChanged = false\n    this._deps.forEach((dep) => {\n      if (dep._produceIfNeededAt(clockNumber)) depsChanged = true\n    })\n    this._producerOperations.forEach((op) => {\n      if (op._produceIfNeededAt(clockNumber)) depsChanged = true\n    })\n    if (!depsChanged && this._producedClockNumber > 0) return false\n\n    this._producedClockNumber = clockNumber\n    return true\n  }\n\n  get current(): T {\n    const currentDerived = this._ctx._currentAction\n    if (!currentDerived)\n      throw new Error(\n        \"It's only possible to read properties from within a reactive context\",\n      )\n    currentDerived._attachDependency(this)\n\n    this._runIfNeededAt(this._ctx._currentClockNumber)\n\n    return this._cachedResult as T\n  }\n\n  getNonReactively(): T {\n    return this._cachedResult as T\n  }\n}\n","import { ContextImplementation } from \"./Context\"\nimport { PropertyReadOnly } from \"./Property\"\n\nexport type Operation = Pick<\n  OperationImplementation,\n  \"_produceIfNeededAt\" | \"_attachDependency\"\n>\n\nexport class OperationImplementation implements Operation {\n  _ctx: ContextImplementation\n  _fn: (ctx: unknown) => void\n  _deps = new Set<PropertyReadOnly<unknown>>()\n  _producedClockNumber: number = 0\n\n  constructor(ctx: ContextImplementation, fn: (ctx: unknown) => void) {\n    this._ctx = ctx\n    this._fn = fn\n  }\n\n  _attachDependency(dep: PropertyReadOnly<unknown>): void {\n    this._deps.add(dep)\n  }\n\n  _produceIfNeededAt(clockNumber: number): boolean {\n    if (this._producedClockNumber >= clockNumber) return false\n    const originalClockNumber = this._producedClockNumber\n    this._producedClockNumber = clockNumber\n\n    var depsChanged = false\n    this._deps.forEach((op) => {\n      if (op._runIfNeededAt(clockNumber)) depsChanged = true\n    })\n    this._deps.forEach((op) => {\n      if (op._produceIfNeededAt(clockNumber)) depsChanged = true\n    })\n    if (!depsChanged && originalClockNumber > 0) return false\n\n    const outerAction = this._ctx._currentAction\n    this._ctx._currentAction = this\n\n    this._fn(this._ctx)\n\n    this._ctx._currentAction = outerAction\n\n    return true\n  }\n}\n","import { ContextImplementation } from \"./Context\"\nimport { PropertyReadOnly } from \"./Property\"\n\nexport type Effect = Pick<\n  EffectImplementation,\n  \"_attachDependency\" | \"_runIfNeededAt\"\n>\n\nexport class EffectImplementation implements Effect {\n  _ctx: ContextImplementation\n  _fn: (ctx: unknown) => (() => {}) | undefined\n  _deps = new Set<PropertyReadOnly<unknown>>()\n  _lastCancelFn?: () => {}\n  _lastClockNumber = 0\n\n  constructor(\n    ctx: ContextImplementation,\n    fn: (ctx: unknown) => (() => {}) | undefined,\n  ) {\n    this._ctx = ctx\n    this._fn = fn\n  }\n\n  _attachDependency(dep: PropertyReadOnly<unknown>): void {\n    this._deps.add(dep)\n  }\n\n  _runIfNeededAt(clockNumber: number) {\n    if (this._lastClockNumber >= clockNumber) return true\n\n    var depsChanged = false\n    this._deps.forEach((dep) => {\n      if (dep._runIfNeededAt(clockNumber)) depsChanged = true\n    })\n    if (!depsChanged && this._lastClockNumber > 0) return false\n\n    const lastCancelFn = this._lastCancelFn\n    if (lastCancelFn) lastCancelFn()\n\n    const outerAction = this._ctx._currentAction\n    this._ctx._currentAction = this\n\n    this._lastCancelFn = this._fn(this._ctx)\n\n    this._ctx._currentAction = outerAction\n    this._lastClockNumber = clockNumber\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Unit } from \"./Unit\"\nimport { Property, PropertyImplementation, PropertyReadOnly } from \"./Property\"\nimport { Derived, DerivedImplementation } from \"./Derived\"\nimport { OperationImplementation } from \"./Operation\"\nimport { EffectImplementation } from \"./Effect\"\nimport { Effect } from \"./Effect\"\n\nexport type MaybeDestroyableGPUResource =\n  | undefined\n  | 0\n  | false\n  | null\n  | (GPUObjectBase & { destroy?: () => void })\n\ntype AttachDependency = Pick<\n  DerivedImplementation<unknown>,\n  \"_attachDependency\"\n>\n\nexport class ContextImplementation {\n  _currentAction?: AttachDependency\n  _currentClockNumber: number = 1\n\n  _effects: Effect[] = []\n\n  _device: GPUDevice\n  _commandEncoder?: GPUCommandEncoder\n\n  constructor(device: GPUDevice) {\n    // TODO: Remove this polyfill when Chromium is working properly.\n    // Current versions of Chromium on Linux leave these properties undefined,\n    // even though the type declarations say they are mandatory properties.\n    const originalCreateBuffer = device.createBuffer.bind(device)\n    ;(device as any).createBuffer = (descriptor: GPUBufferDescriptor) => {\n      const result = originalCreateBuffer(descriptor)\n      ;(result as any).size = descriptor.size\n      ;(result as any).usage = descriptor.usage\n      return result\n    }\n\n    // TODO: Remove this polyfill when Chromium is working properly.\n    // Current versions of Chromium on Linux leave these properties undefined,\n    // even though the type declarations say they are mandatory properties.\n    const originalCreateTexture = device.createTexture.bind(device)\n    ;(device as any).createTexture = (descriptor: GPUTextureDescriptor) => {\n      const result = originalCreateTexture(descriptor)\n      ;(result as any).width = (descriptor.size as any).width\n      ;(result as any).height = (descriptor.size as any).height\n      ;(result as any).format = descriptor.format\n      return result\n    }\n\n    this._device = device\n  }\n\n  get commandEncoder(): GPUCommandEncoder | undefined {\n    return this._commandEncoder\n  }\n\n  get device(): GPUDevice {\n    return this._device\n  }\n\n  _useProp<T>(initialValue: (() => T) | T): Property<T> {\n    return new PropertyImplementation<T>(\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue,\n      this,\n    )\n  }\n\n  _useGPUResource<T extends MaybeDestroyableGPUResource>(\n    fn: (ctx: ContextForGPUResource) => T,\n  ): Derived<T> {\n    return new DerivedImplementation<T>(this, fn as any)\n  }\n\n  _useGPUUpdate(\n    producedProps: PropertyReadOnly<unknown>[],\n    fn: (ctx: ContextForGPUAction) => void,\n  ) {\n    const op = new OperationImplementation(this, fn as any)\n\n    producedProps.forEach((prop) => prop._attachProducerOperation(op))\n  }\n\n  _useEffect(fn: (ctx: ContextEmpty) => (() => void) | undefined) {\n    this._effects.push(new EffectImplementation(this, fn as any))\n  }\n\n  _useDerived<T>(fn: (ctx: ContextEmpty) => T): Derived<T> {\n    return new DerivedImplementation<T>(this, fn as any)\n  }\n}\n\nexport type Context = Pick<\n  ContextImplementation,\n  // In the main function context, hooks are available.\n  | \"device\"\n  | \"_useProp\"\n  | \"_useGPUResource\"\n  | \"_useGPUUpdate\"\n  | \"_useEffect\"\n  | \"_useDerived\"\n>\n\nexport type ContextForGPUResource = Pick<\n  ContextImplementation,\n  // No hooks are available.\n  \"device\"\n>\n\nexport type ContextForGPUAction = Pick<\n  ContextImplementation,\n  // No hooks are available, but a command encoder is available.\n  \"device\"\n> & { commandEncoder: GPUCommandEncoder }\n\nexport type ContextEmpty = {}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { UnitFn, createUnitRoot, Render } from \"@gpu-fu/gpu-fu\"\nimport { OutputCanvas } from \"@gpu-fu/incubator\"\n\ntype FrameFn = (commandEncoder: GPUCommandEncoder) => void\ntype SetupFn = (device: GPUDevice, canvasContext: GPUCanvasContext) => FrameFn\n\nexport default function runDemo(renderFn: UnitFn<Render>) {\n  runDemoInner((device, canvasContext) => {\n    const render = createUnitRoot(device, renderFn)\n\n    const output = new OutputCanvas(canvasContext)\n    output.addRender(render)\n\n    return function frame(commandEncoder) {\n      output.outputFrame(commandEncoder)\n    }\n  })\n}\n\nfunction runDemoInner(setupFn: SetupFn) {\n  ;(async () => {\n    const device = await getDevice()\n    const canvasContext = await getCanvasContext(getDemoCanvas(), device)\n\n    const frameFn = setupFn(device, canvasContext)\n\n    function repeatFrameWithContext() {\n      runFrameWithContext(device, frameFn)\n      requestAnimationFrame(repeatFrameWithContext)\n    }\n    requestAnimationFrame(repeatFrameWithContext)\n  })().catch((error) => {\n    document.querySelector(\"body\")!.innerHTML = error\n    console.error(error)\n  })\n}\n\nasync function getDevice(\n  powerPreference: GPUPowerPreference = \"high-performance\",\n): Promise<GPUDevice> {\n  if (!navigator.gpu)\n    throw new Error(\"Your browser doesn't have WebGPU enabled!\")\n\n  const gpu = await navigator.gpu.requestAdapter({ powerPreference })\n  if (!gpu) throw new Error(\"Failed to get the GPU adapter!\")\n\n  return gpu.requestDevice()\n}\n\nexport function getDemoCanvas(): HTMLCanvasElement {\n  const canvas = document.querySelector(\n    \"canvas.main\",\n  ) as HTMLCanvasElement | null\n  if (!canvas) throw new Error(\"The main canvas wasn't found in the HTML!\")\n\n  return canvas\n}\n\nasync function getCanvasContext(\n  canvas: HTMLCanvasElement,\n  device: GPUDevice,\n): Promise<GPUCanvasContext> {\n  const canvasContext = canvas.getContext(\"webgpu\") as GPUCanvasContext | null\n  if (!canvasContext) throw new Error(\"Failed to get a WebGPU canvas context!\")\n\n  canvasContext.configure({\n    device,\n    format: getPreferredCanvasFormat(),\n    alphaMode: \"opaque\",\n    compositingAlphaMode: \"opaque\",\n  })\n\n  return canvasContext\n}\n\nfunction getPreferredCanvasFormat() {\n  // Some browsers throw an \"Illegal invocation\" error if we don't bind.\n  const getPreferredCanvasFormat =\n    navigator.gpu?.getPreferredCanvasFormat?.bind(navigator.gpu)\n  if (getPreferredCanvasFormat) return getPreferredCanvasFormat()\n\n  // Hard-coded default for browsers that don't implement this function yet.\n  return \"rgba8unorm\"\n}\n\nfunction runFrameWithContext(device: GPUDevice, frameFn: FrameFn) {\n  const commandEncoder = device.createCommandEncoder()\n  frameFn(commandEncoder)\n  device.queue.submit([commandEncoder.finish()])\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { useUnit } from \"@gpu-fu/gpu-fu\"\nimport {\n  TextureSourceBitmapFromURL,\n  TextureFilterConvolve,\n  RenderTextureRect,\n} from \"@gpu-fu/incubator\"\n\nimport runDemo from \"./runDemo\"\nrunDemo((ctx) => {\n  const textureSource = useUnit(ctx, TextureSourceBitmapFromURL)\n  textureSource.url.set(\"./assets/fireweed.jpg\")\n\n  const sobelHorizontal = useUnit(ctx, TextureFilterConvolve)\n  sobelHorizontal.textureSource.setFrom(textureSource.resultTexture)\n  sobelHorizontal.setKernel3x3(\n    // Sobel Horizontal Kernel (with scaling and bias to center on gray)\n    [1, 2, 1],\n    [0, 0, 0],\n    [-1, -2, -1],\n    { scale: 0.5, bias: 0.5 },\n  )\n\n  const { renderTarget, ...render } = useUnit(ctx, RenderTextureRect)\n  render.textureSource.setFrom(sobelHorizontal.resultTexture)\n\n  return { renderTarget }\n})\n","import { Context, ContextImplementation } from \"./Context\"\nimport { PropertyReadOnly } from \"./Property\"\n\nexport type Unit<U> = U & {\n  _ctx: ContextImplementation\n}\n\nexport type UnitRoot<U> = U & {\n  _ctx: ContextImplementation\n  runFrame: (\n    commandEncoder: GPUCommandEncoder,\n    outputs: PropertyReadOnly<unknown>[],\n  ) => void\n}\n\nexport type UnitFn<U> = (ctx: Context) => U\n\nexport function createUnitRoot<U>(\n  device: GPUDevice,\n  unitFn: UnitFn<U>,\n): UnitRoot<U> {\n  const ctx = new ContextImplementation(device)\n  const unitRoot = { ...unitFn(ctx), _ctx: ctx } as UnitRoot<U>\n  unitRoot.runFrame = (\n    commandEncoder: GPUCommandEncoder,\n    outputs: PropertyReadOnly<unknown>[],\n  ) => {\n    ctx._currentClockNumber += 1\n    ctx._commandEncoder = commandEncoder\n\n    const clockNumber = ctx._currentClockNumber\n    outputs.forEach((output) => output._produceIfNeededAt(clockNumber))\n\n    ctx._effects.forEach((effect) => effect._runIfNeededAt(clockNumber))\n\n    ctx._commandEncoder = undefined\n  }\n  return unitRoot\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","ctx","_useProp","undefined","useUnit","unitFn","_ctx","_current","create","_useGPUResource","producedProps","action","_useGPUUpdate","Symbol","toStringTag","Object","defineProperty","value","OutputCanvas","constructor","canvasContext","_renders","_canvasContext","addRender","render","includes","push","outputFrame","commandEncoder","target","getCurrentTexture","width","canvas","height","format","forEach","renderTarget","setAndNotify","runFrame","resultVertexBufferLayout","xyzwOffsetBytes","uvOffsetBytes","Float32Array","BYTES_PER_ELEMENT","strideBytes","VertexSourceRect","aspectFillRatio","resultVertexBuffer","device","createBuffer","size","usage","GPUBufferUsage","VERTEX","COPY_DST","current","uMin","uMax","vMin","vMax","data","queue","writeBuffer","length","RenderTextureRect","textureSource","vertexBuffer","vertexBufferLayout","cameraMatrixBuffer","shaderModule","createShaderModule","code","renderPipeline","createRenderPipeline","layout","primitive","topology","vertex","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","depthStencil","depthWriteEnabled","depthCompare","sampler","createSampler","magFilter","minFilter","bindGroup","entries","binding","resource","createView","unshift","buffer","createBindGroup","getBindGroupLayout","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","vertexCount","passEncoder","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","setPipeline","setVertexBuffer","setBindGroup","draw","end","rect","setFrom","set","_useDerived","useDerived","TextureFilterConvolve","kernelData","kernelBuffer","byteLength","UNIFORM","computePipeline","shaderModuleCode","createComputePipeline","compute","resultTexture","STORAGE_BINDING","TEXTURE_BINDING","beginComputePass","dispatchWorkgroups","setKernel3x3","row0","row1","row2","opts","scale","normalize","sum","reduce","accum","n","map","newKernelData","bias","TextureSourceBitmapFromURL","imageBitmap","label","texture","copyExternalImageToTexture","source","TextureSourceBitmap","url","effect","_useEffect","currentURL","cancelled","img","document","createElement","src","decode","then","createImageBitmap","newImageBitmap","catch","console","error","PropertyImplementation","initialValue","_changeAtNextTick","_changedClockNumber","_producedClockNumber","_producerOperations","_next","_attachProducerOperation","op","_runIfNeededAt","clockNumber","readingFrom","_readingFrom","_produceIfNeededAt","depsChanged","currentAction","_currentAction","Error","_attachDependency","getNonReactively","readOnly","other","newValue","notify","change","fn","mutate","DerivedImplementation","_deps","Set","_cachedClockNumber","_fn","dep","add","outerAction","previousResult","_cachedResult","destroy","currentDerived","_currentClockNumber","OperationImplementation","originalClockNumber","EffectImplementation","_lastClockNumber","lastCancelFn","_lastCancelFn","ContextImplementation","_effects","originalCreateBuffer","bind","descriptor","result","originalCreateTexture","_device","_commandEncoder","prop","getPreferredCanvasFormat","navigator","gpu","renderFn","sobelHorizontal","setupFn","powerPreference","requestAdapter","requestDevice","getDevice","getContext","configure","alphaMode","compositingAlphaMode","getCanvasContext","querySelector","getDemoCanvas","frameFn","unitRoot","outputs","output","createUnitRoot","requestAnimationFrame","repeatFrameWithContext","createCommandEncoder","submit","finish","runFrameWithContext","innerHTML","runDemoInner"],"sourceRoot":""}