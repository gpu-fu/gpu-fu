{"version":3,"file":"demo3.js","mappings":"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","sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/webpack/runtime/make namespace object","webpack://beta/../incubator/src/OutputCanvas.ts","webpack://beta/../incubator/src/RenderUV.ts","webpack://beta/../incubator/src/RenderUV.wgsl","webpack://beta/../incubator/src/VertexSourceRect.ts","webpack://beta/../incubator/src/RenderTextureRect.ts","webpack://beta/../incubator/src/TextureFilterConvolve.ts","webpack://beta/../incubator/src/TextureFilterConvolve3x3.wgsl","webpack://beta/../incubator/src/TextureSourceBitmap.ts","webpack://beta/./src/runDemo.ts","webpack://beta/./src/demo3.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, Render } from \"@gpu-fu/gpu-fu\"\n\nexport default class OutputCanvas {\n  _canvasContext: GPUCanvasContext\n  _renders: Render[] = []\n\n  constructor(canvasContext: GPUCanvasContext) {\n    this._canvasContext = canvasContext\n  }\n\n  addRender(render: Render) {\n    if (this._renders.includes(render)) return\n    this._renders.push(render)\n  }\n\n  outputFrame(ctx: Context, frame: number) {\n    const target = this._canvasContext.getCurrentTexture()\n    this._renders.forEach((render) => {\n      render.renderFrame(ctx, frame, target)\n    })\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  Context,\n  Render,\n  VertexSource,\n  TextureSource,\n  autoLayout,\n} from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode from \"./RenderUV.wgsl\"\n\nexport default class RenderUV implements Render {\n  private _vertexSource?: VertexSource\n  private _textureSource?: TextureSource\n\n  private _shaderModule?: GPUShaderModule\n  private _renderPipeline?: GPURenderPipeline\n  private _bindGroup?: GPUBindGroup\n\n  getVertexSource(): VertexSource {\n    if (this._vertexSource) return this._vertexSource\n    throw new Error(`${this} has no _vertexSource`)\n  }\n\n  setVertexSource(vertexSource: VertexSource) {\n    this._vertexSource = vertexSource\n    this._renderPipeline = undefined\n    this._bindGroup = undefined\n  }\n\n  getTextureSource(): TextureSource {\n    if (this._textureSource) return this._textureSource\n    throw new Error(`${this} has no _textureSource`)\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._textureSource = textureSource\n    this._renderPipeline = undefined\n    this._bindGroup = undefined\n  }\n\n  getShaderModule(ctx: Context): GPUShaderModule {\n    if (this._shaderModule) return this._shaderModule\n\n    return (this._shaderModule = ctx.device.createShaderModule({\n      code: shaderModuleCode,\n    }))\n  }\n\n  getRenderPipeline(ctx: Context): GPURenderPipeline {\n    if (this._renderPipeline) return this._renderPipeline\n\n    const vertexSource = this.getVertexSource()\n\n    return (this._renderPipeline = ctx.device.createRenderPipeline({\n      vertex: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"vertexRenderUV\",\n        buffers: [\n          {\n            arrayStride: vertexSource.vertexSourceStrideBytes(ctx),\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: vertexSource.vertexSourceXYZWOffsetBytes(ctx),\n                format: \"float32x4\" as GPUVertexFormat,\n              },\n              {\n                shaderLocation: 1,\n                offset: vertexSource.vertexSourceUVOffsetBytes(ctx),\n                format: \"float32x2\" as GPUVertexFormat,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"fragmentRenderUV\",\n        targets: [\n          {\n            // TODO: Remove this hard-coded value - get the real one somehow.\n            format: \"rgba8unorm\" as GPUTextureFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: \"triangle-list\",\n      },\n      layout: autoLayout(),\n    }))\n  }\n\n  getBindGroup(ctx: Context) {\n    if (this._bindGroup) return this._bindGroup\n\n    const sampler = ctx.device.createSampler({\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n    })\n\n    return (this._bindGroup = ctx.device.createBindGroup({\n      layout: this.getRenderPipeline(ctx).getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: sampler,\n        },\n        {\n          binding: 1,\n          resource: this.getTextureSource()\n            .textureSourceAsGPUTexture(ctx)\n            .createView(),\n        },\n      ],\n    }))\n  }\n\n  renderFrame(ctx: Context, frame: number, target: GPUTexture): void {\n    this.getTextureSource().textureSourceFrame(ctx, frame)\n    const vertexCount = this.getVertexSource().vertexSourceFrame(ctx, frame)\n\n    const passEncoder = ctx.commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: target.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: \"clear\" as GPULoadOp,\n          storeOp: \"store\" as GPUStoreOp,\n        },\n      ],\n    })\n    passEncoder.setPipeline(this.getRenderPipeline(ctx))\n    passEncoder.setVertexBuffer(\n      0,\n      this.getVertexSource().vertexSourceAsGPUBuffer(ctx),\n    )\n    passEncoder.setBindGroup(0, this.getBindGroup(ctx))\n    passEncoder.draw(vertexCount, 1, 0, 0)\n    passEncoder.end()\n  }\n}\n","export default \"@group(0) @binding(0) var use_sampler: sampler;\\n@group(0) @binding(1) var use_texture: texture_2d<f32>;\\n\\nstruct VertexOutput {\\n  @builtin(position) pos: vec4<f32>;\\n  @location(0) uv: vec2<f32>;\\n}\\n\\n@stage(vertex)\\nfn vertexRenderUV(\\n  @location(0) pos_in: vec4<f32>,\\n  @location(1) uv_in: vec2<f32>,\\n) ->\\n  VertexOutput\\n{\\n  var out: VertexOutput;\\n  out.pos = pos_in;\\n  out.uv = uv_in;\\n  return out;\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderUV(\\n  @location(0) uv_in : vec2<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return textureSample(use_texture, use_sampler, uv_in.xy);\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, VertexSource } from \"@gpu-fu/gpu-fu\"\n\nexport default class VertexSourceRect implements VertexSource {\n  private _aspectFillRatio?: number\n\n  private _buffer?: GPUBuffer\n  private _bufferUpToDate = false\n\n  setAspectFillRatio(ratio: number) {\n    if (this._aspectFillRatio === ratio) return\n    this._aspectFillRatio = ratio\n    this._bufferUpToDate = false\n  }\n\n  private getBuffer(ctx: Context): GPUBuffer {\n    if (this._buffer) return this._buffer\n\n    const buffer = ctx.device.createBuffer({\n      size: this.vertexSourceTotalBytes(ctx),\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    })\n\n    return (this._buffer = buffer)\n  }\n\n  private updateBuffer(ctx: Context) {\n    if (this._bufferUpToDate) return\n\n    var uMin = 0\n    var uMax = 1\n    var vMin = 0\n    var vMax = 1\n\n    if (this._aspectFillRatio) {\n      if (this._aspectFillRatio < 1) {\n        vMin = 0.5 - 0.5 * this._aspectFillRatio\n        vMax = 1 - vMin\n      } else {\n        uMin = 0.5 - 0.5 / this._aspectFillRatio\n        uMax = 1 - uMin\n      }\n    }\n\n    // prettier-ignore\n    const data = new Float32Array([\n    // (x, y, z, w),  (u, v)\n        1, 1, 0, 1, uMax, vMin,\n       -1,-1, 0, 1, uMin, vMax,\n       -1, 1, 0, 1, uMin, vMin,\n        1, 1, 0, 1, uMax, vMin,\n        1,-1, 0, 1, uMax, vMax,\n       -1,-1, 0, 1, uMin, vMax,\n    ])\n\n    ctx.device.queue.writeBuffer(this.getBuffer(ctx), 0, data, 0, data.length)\n\n    this._bufferUpToDate = true\n  }\n\n  vertexSourceAsGPUBuffer(ctx: Context): GPUBuffer {\n    return this.getBuffer(ctx)\n  }\n\n  vertexSourceTotalBytes = (ctx: Context) => 6 * 6 * 4\n  vertexSourceStrideBytes = (ctx: Context) => 6 * 4\n  vertexSourceXYZWOffsetBytes = (ctx: Context) => 0\n  vertexSourceUVOffsetBytes = (ctx: Context) => 4 * 4\n\n  vertexSourceFrame(ctx: Context, frame: number) {\n    this.updateBuffer(ctx)\n    return 6\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, Render, TextureSource } from \"@gpu-fu/gpu-fu\"\nimport RenderUV from \"./RenderUV\"\nimport VertexSourceRect from \"./VertexSourceRect\"\n\nexport default class RenderTextureRect implements Render {\n  private _renderUV = new RenderUV()\n\n  constructor() {\n    this._renderUV.setVertexSource(new VertexSourceRect())\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._renderUV.setTextureSource(textureSource)\n  }\n\n  renderFrame(ctx: Context, frame: number, target: GPUTexture): void {\n    // TODO : Use the source texture and target texture aspect ratios\n    // instead of hard-coding a number here.\n    // This doesn't yet work on the latest version of chromium, because\n    // those chromium builds don't yet expose texture width and height.\n    ;(this._renderUV.getVertexSource() as VertexSourceRect).setAspectFillRatio(\n      850 / 1275,\n    )\n    this._renderUV.renderFrame(ctx, frame, target)\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  Context,\n  TextureFilter,\n  TextureSource,\n  autoLayout,\n} from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode3x3 from \"./TextureFilterConvolve3x3.wgsl\"\n\ninterface SetKernelOptions {\n  bias?: number\n  scale?: number\n  normalize?: boolean\n}\n\nexport default class TextureFilterConvolve implements TextureFilter {\n  private _textureSource?: TextureSource\n  private _kernelData?: Float32Array\n\n  private _kernelBuffer?: GPUBuffer\n  private _kernelBufferUpToDate = false\n  private _texture?: GPUTexture\n  private _shaderModule?: GPUShaderModule\n  private _computePipeline?: GPUComputePipeline\n  private _bindGroup?: GPUBindGroup\n\n  private getKernelData(): Float32Array {\n    if (this._kernelData) return this._kernelData\n    throw new Error(`${this} has no _kernelData`)\n  }\n\n  setKernel3x3(\n    row0: [number, number, number],\n    row1: [number, number, number],\n    row2: [number, number, number],\n    opts: SetKernelOptions = {},\n  ) {\n    // Respect scale and/or normalize options if present.\n    if (opts.scale || opts.normalize) {\n      var scale = opts.scale ?? 1\n      if (opts.normalize) {\n        var sum = 0\n        sum = row0.reduce((accum, n) => accum + n, sum)\n        sum = row1.reduce((accum, n) => accum + n, sum)\n        sum = row2.reduce((accum, n) => accum + n, sum)\n        if (sum !== 0) scale = scale / sum\n      }\n      if (scale !== 1) {\n        row0 = row0.map((n) => n * scale) as typeof row0\n        row1 = row1.map((n) => n * scale) as typeof row1\n        row2 = row2.map((n) => n * scale) as typeof row2\n      }\n    }\n\n    // Create the kernel data array and fill it with data.\n    const kernelData = new Float32Array(10)\n    kernelData[0] = opts.bias ?? 0\n    kernelData.set(row0, 1)\n    kernelData.set(row1, 4)\n    kernelData.set(row2, 7)\n\n    // If the kernel size has changed, it invalidates almost everything.\n    if (kernelData.byteLength !== this._kernelData?.byteLength) {\n      this._kernelBuffer = undefined\n      this._shaderModule = undefined\n      this._computePipeline = undefined\n      this._bindGroup = undefined\n    }\n\n    // Assign the kernel data array and mark the buffer data as invalidated.\n    this._kernelData = kernelData\n    this._kernelBufferUpToDate = false\n  }\n\n  getTextureSource(): TextureSource {\n    if (this._textureSource) return this._textureSource\n    throw new Error(`${this} has no _textureSource`)\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._textureSource = textureSource\n    this._bindGroup = undefined\n  }\n\n  private getKernelBuffer(ctx: Context): GPUBuffer {\n    if (this._kernelBuffer) return this._kernelBuffer\n\n    console.log(\"byteLength\", this.getKernelData().byteLength)\n\n    const buffer = ctx.device.createBuffer({\n      size: this.getKernelData().byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    })\n\n    return (this._kernelBuffer = buffer)\n  }\n\n  private updateKernelBuffer(ctx: Context) {\n    if (this._kernelBufferUpToDate) return\n\n    const data = this.getKernelData()\n\n    ctx.device.queue.writeBuffer(\n      this.getKernelBuffer(ctx),\n      0,\n      data,\n      0,\n      data.length,\n    )\n\n    this._kernelBufferUpToDate = true\n  }\n\n  private getShaderModule(ctx: Context): GPUShaderModule {\n    if (this._shaderModule) return this._shaderModule\n\n    let shaderModuleCode: string\n    switch (this.getKernelData().length) {\n      case 10:\n        shaderModuleCode = shaderModuleCode3x3\n        break\n      default:\n        throw new Error(\"_kernelData length is invalid!\")\n    }\n\n    return (this._shaderModule = ctx.device.createShaderModule({\n      code: shaderModuleCode,\n    }))\n  }\n\n  private getComputePipeline(ctx: Context): GPUComputePipeline {\n    if (this._computePipeline) return this._computePipeline\n\n    return (this._computePipeline = ctx.device.createComputePipeline({\n      compute: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"computeTextureFilterConvolve3x3\",\n      },\n      layout: autoLayout(),\n    }))\n  }\n\n  private getBindGroup(ctx: Context) {\n    if (this._bindGroup) return this._bindGroup\n\n    const sampler = ctx.device.createSampler({\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n    })\n\n    return (this._bindGroup = ctx.device.createBindGroup({\n      layout: this.getComputePipeline(ctx).getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: this.getKernelBuffer(ctx) },\n        },\n        {\n          binding: 1,\n          resource: this.getTextureSource()\n            .textureSourceAsGPUTexture(ctx)\n            .createView(),\n        },\n        {\n          binding: 2,\n          resource: this.textureSourceAsGPUTexture(ctx).createView(),\n        },\n      ],\n    }))\n  }\n\n  textureSourceAsGPUTexture(ctx: Context): GPUTexture {\n    if (this._texture) return this._texture\n\n    const textureSource = this.getTextureSource().textureSourceAsGPUTexture(ctx)\n\n    this._texture = ctx.device.createTexture({\n      format: \"rgba8unorm\",\n      size: {\n        width: textureSource.width || 850, // TODO: remove fallback value\n        height: textureSource.height || 1275, // TODO: remove fallback value\n      },\n      usage:\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.STORAGE_BINDING |\n        GPUTextureUsage.TEXTURE_BINDING,\n    })\n\n    return this._texture\n  }\n\n  textureSourceFrame(ctx: Context, frame: number) {\n    this.updateKernelBuffer(ctx)\n\n    const textureSource = this.getTextureSource().textureSourceAsGPUTexture(ctx)\n    const workGroupSizeX = 32 // (must match the WGSL code)\n    const workGroupSizeY = 1 // (must match the WGSL code)\n\n    const passEncoder = ctx.commandEncoder.beginComputePass()\n    passEncoder.setPipeline(this.getComputePipeline(ctx))\n    passEncoder.setBindGroup(0, this.getBindGroup(ctx))\n    passEncoder.dispatch(\n      (textureSource.width || 850) / workGroupSizeX, // TODO: remove fallback value\n      (textureSource.height || 1275) / workGroupSizeY, // TODO: remove fallback value\n    )\n    passEncoder.end()\n  }\n}\n","export default \"@group(0) @binding(0) var<uniform> kernel_3x3: Kernel3x3;\\n@group(0) @binding(1) var texture_in: texture_2d<f32>;\\n@group(0) @binding(2) var texture_out: texture_storage_2d<rgba8unorm, write>;\\n\\nstruct Kernel3x3 {\\n  bias: f32;\\n  aa: f32;\\n  ba: f32;\\n  ca: f32;\\n  ab: f32;\\n  bb: f32;\\n  cb: f32;\\n  ac: f32;\\n  bc: f32;\\n  cc: f32;\\n}\\n\\n// TODO: What is the most likely optimal workgroup size?\\n@stage(compute) @workgroup_size(32, 1, 1)\\nfn computeTextureFilterConvolve3x3(\\n  @builtin(global_invocation_id) global_id: vec3<u32>,\\n) {\\n  let b = vec2<i32>(global_id.xy);\\n  let a = max(b - 1, vec2<i32>(0));\\n  let c = min(b + 1, min(\\n    textureDimensions(texture_in),\\n    textureDimensions(texture_out),\\n  ));\\n\\n  var sum = vec4<f32>(kernel_3x3.bias);\\n\\n  sum = sum + kernel_3x3.aa * textureLoad(texture_in, vec2<i32>(a.x, a.y), 0);\\n  sum = sum + kernel_3x3.ba * textureLoad(texture_in, vec2<i32>(b.x, a.y), 0);\\n  sum = sum + kernel_3x3.ca * textureLoad(texture_in, vec2<i32>(c.x, a.y), 0);\\n\\n  sum = sum + kernel_3x3.ab * textureLoad(texture_in, vec2<i32>(a.x, b.y), 0);\\n  sum = sum + kernel_3x3.bb * textureLoad(texture_in, vec2<i32>(b.x, b.y), 0);\\n  sum = sum + kernel_3x3.cb * textureLoad(texture_in, vec2<i32>(c.x, b.y), 0);\\n\\n  sum = sum + kernel_3x3.ac * textureLoad(texture_in, vec2<i32>(a.x, c.y), 0);\\n  sum = sum + kernel_3x3.bc * textureLoad(texture_in, vec2<i32>(b.x, c.y), 0);\\n  sum = sum + kernel_3x3.cc * textureLoad(texture_in, vec2<i32>(c.x, c.y), 0);\\n\\n  textureStore(texture_out, b, sum);\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, TextureSource } from \"@gpu-fu/gpu-fu\"\n\nexport default class TextureSourceBitmap implements TextureSource {\n  private _imageBitmap: ImageBitmap\n  private _label: string\n\n  private _texture?: GPUTexture\n\n  constructor(imageBitmap: ImageBitmap, label: string) {\n    this._imageBitmap = imageBitmap\n    this._label = label\n  }\n\n  static async fromURL(url: string, label?: string) {\n    const img = document.createElement(\"img\")\n    img.src = url\n    await img.decode()\n    const imageBitmap = await createImageBitmap(img)\n    return new TextureSourceBitmap(imageBitmap, label ?? url)\n  }\n\n  textureSourceAsGPUTexture(ctx: Context): GPUTexture {\n    if (this._texture) return this._texture\n\n    this._texture = ctx.device.createTexture({\n      label: this._label,\n      size: [this._imageBitmap.width, this._imageBitmap.height, 1],\n      format: \"rgba8unorm\",\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    })\n\n    ctx.device.queue.copyExternalImageToTexture(\n      { source: this._imageBitmap },\n      { texture: this._texture },\n      [this._imageBitmap.width, this._imageBitmap.height],\n    )\n\n    console.log(this._texture)\n\n    return this._texture\n  }\n\n  textureSourceFrame(ctx: Context, frame: number): void {}\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context } from \"@gpu-fu/gpu-fu\"\n\ntype FrameFn = (ctx: Context, frame: number) => void\ntype SetupFn = (\n  device: GPUDevice,\n  canvasContext: GPUCanvasContext,\n) => Promise<FrameFn>\n\nexport default function runDemo(setupFn: SetupFn) {\n  ;(async () => {\n    const device = await getDevice()\n    const canvasContext = await getCanvasContext(\"canvas.main\", device)\n\n    const frameFn = await setupFn(device, canvasContext)\n\n    var frame = 0\n    function repeatFrameWithContext() {\n      frame = frame + 1\n      runFrameWithContext(device, frame, frameFn)\n      requestAnimationFrame(repeatFrameWithContext)\n    }\n    requestAnimationFrame(repeatFrameWithContext)\n  })().catch((error) => {\n    document.querySelector(\"body\")!.innerHTML = error\n    console.error(error)\n  })\n}\n\nasync function getDevice(\n  powerPreference: GPUPowerPreference = \"high-performance\",\n): Promise<GPUDevice> {\n  if (!navigator.gpu)\n    throw new Error(\"Your browser doesn't have WebGPU enabled!\")\n\n  const gpu = await navigator.gpu.requestAdapter({ powerPreference })\n  if (!gpu) throw new Error(\"Failed to get the GPU adapter!\")\n\n  return gpu.requestDevice()\n}\n\nasync function getCanvasContext(\n  querySelector: string,\n  device: GPUDevice,\n): Promise<GPUCanvasContext> {\n  const canvas = document.querySelector(\n    querySelector,\n  ) as HTMLCanvasElement | null\n  if (!canvas) throw new Error(\"The main canvas wasn't found in the HTML!\")\n\n  const canvasContext = canvas.getContext(\"webgpu\") as GPUCanvasContext | null\n  if (!canvasContext) throw new Error(\"Failed to get a WebGPU canvas context!\")\n\n  canvasContext.configure({\n    device,\n    format: getPreferredCanvasFormat(),\n    alphaMode: \"opaque\",\n  })\n\n  return canvasContext\n}\n\nfunction getPreferredCanvasFormat() {\n  // Some browsers throw an \"Illegal invocation\" error if we don't bind.\n  const getPreferredCanvasFormat =\n    navigator.gpu?.getPreferredCanvasFormat?.bind(navigator.gpu)\n  if (getPreferredCanvasFormat) return getPreferredCanvasFormat()\n\n  // Hard-coded default for browsers that don't implement this function yet.\n  return \"rgba8unorm\"\n}\n\nfunction runFrameWithContext(\n  device: GPUDevice,\n  frame: number,\n  frameFn: FrameFn,\n) {\n  const commandEncoder = device.createCommandEncoder()\n  frameFn({ device, commandEncoder }, frame)\n  device.queue.submit([commandEncoder.finish()])\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  TextureSourceBitmap,\n  TextureFilterConvolve,\n  RenderTextureRect,\n  OutputCanvas,\n} from \"@gpu-fu/incubator\"\n\nimport runDemo from \"./runDemo\"\nrunDemo(async (device, canvasContext) => {\n  const textureSource = await TextureSourceBitmap.fromURL(\n    \"./assets/fireweed.jpg\",\n  )\n\n  const sobelHorizontal = new TextureFilterConvolve()\n  sobelHorizontal.setTextureSource(textureSource)\n  sobelHorizontal.setKernel3x3(\n    // Sobel Horizontal Kernel (with scaling and bias to center on gray)\n    [1, 2, 1],\n    [0, 0, 0],\n    [-1, -2, -1],\n    { scale: 0.5, bias: 0.5 },\n  )\n\n  const renderUV = new RenderTextureRect()\n  renderUV.setTextureSource(sobelHorizontal)\n\n  const output = new OutputCanvas(canvasContext)\n  output.addRender(renderUV)\n\n  console.log(canvasContext.getCurrentTexture())\n\n  return function frame(ctx, frame) {\n    output.outputFrame(ctx, frame)\n  }\n})\n"],"names":["root","factory","exports","module","define","amd","self","this","Symbol","toStringTag","Object","defineProperty","value","canvasContext","_renders","_canvasContext","addRender","render","includes","push","outputFrame","ctx","frame","target","getCurrentTexture","forEach","renderFrame","getVertexSource","_vertexSource","Error","setVertexSource","vertexSource","_renderPipeline","undefined","_bindGroup","getTextureSource","_textureSource","setTextureSource","textureSource","getShaderModule","_shaderModule","device","createShaderModule","code","getRenderPipeline","createRenderPipeline","vertex","entryPoint","buffers","arrayStride","vertexSourceStrideBytes","attributes","shaderLocation","offset","vertexSourceXYZWOffsetBytes","format","vertexSourceUVOffsetBytes","fragment","targets","primitive","topology","layout","autoLayout","getBindGroup","sampler","createSampler","magFilter","minFilter","createBindGroup","getBindGroupLayout","entries","binding","resource","textureSourceAsGPUTexture","createView","textureSourceFrame","vertexCount","vertexSourceFrame","passEncoder","commandEncoder","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","setVertexBuffer","vertexSourceAsGPUBuffer","setBindGroup","draw","end","_bufferUpToDate","vertexSourceTotalBytes","setAspectFillRatio","ratio","_aspectFillRatio","getBuffer","_buffer","buffer","createBuffer","size","usage","GPUBufferUsage","VERTEX","COPY_DST","updateBuffer","uMin","uMax","vMin","vMax","data","Float32Array","queue","writeBuffer","length","_renderUV","_kernelBufferUpToDate","getKernelData","_kernelData","setKernel3x3","row0","row1","row2","opts","scale","normalize","sum","reduce","accum","n","map","kernelData","bias","set","byteLength","_kernelBuffer","_computePipeline","getKernelBuffer","console","log","UNIFORM","updateKernelBuffer","getComputePipeline","createComputePipeline","compute","_texture","createTexture","width","height","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","beginComputePass","dispatch","imageBitmap","label","_imageBitmap","_label","fromURL","url","img","document","createElement","src","decode","createImageBitmap","TextureSourceBitmap","RENDER_ATTACHMENT","copyExternalImageToTexture","source","texture","getDevice","powerPreference","navigator","gpu","requestAdapter","requestDevice","getCanvasContext","querySelector","canvas","getContext","configure","getPreferredCanvasFormat","alphaMode","bind","setupFn","repeatFrameWithContext","frameFn","createCommandEncoder","submit","finish","runFrameWithContext","requestAnimationFrame","error","innerHTML","runDemo","sobelHorizontal","renderUV","output"],"sourceRoot":""}