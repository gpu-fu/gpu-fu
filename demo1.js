!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.beta=t():e.beta=t()}("undefined"!=typeof self?self:this,(()=>(()=>{"use strict";var e={};(e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})})(e);class t{constructor(e,t){this._changeAtNextTick=!1,this._changedClockNumber=0,this._producedClockNumber=0,this._producerOperations=[],this._current=e,this._next=e,this._ctx=t}_attachProducerOperation(e){this._producerOperations.push(e)}_runIfNeededAt(e){return this._changeAtNextTick?(this._current=this._next,this._changeAtNextTick=!1,this._changedClockNumber=e,!0):this._changedClockNumber>=e}_produceIfNeededAt(e){this._producedClockNumber>=e||(this._producerOperations.forEach((t=>t._produceIfNeededAt(e))),this._producedClockNumber=e)}get current(){const e=this._ctx._currentAction;if(!e)throw new Error("It's only possible to read properties from within a reactive context");return e._attachDependency(this),this._current}getNonReactively(){return this._current}get readOnly(){return this}set(e){this._current!==e&&this.setAndNotify(e)}setAndNotify(e){this._next=e,this.notify()}change(e){this.set(e(this._current))}mutate(e){e(this._current),this.notify()}notify(){this._changeAtNextTick=!0}}class r{constructor(e,t){this._deps=new Set,this._cachedClockNumber=0,this._producedClockNumber=0,this._producerOperations=[],this._ctx=e,this._fn=t}_attachDependency(e){this._deps.add(e)}_attachProducerOperation(e){this._producerOperations.push(e)}_runIfNeededAt(e){if(this._cachedClockNumber>=e)return!0;var t=!1;if(this._deps.forEach((r=>{r._runIfNeededAt(e)&&(t=!0)})),!t&&this._cachedClockNumber>0)return!1;const r=this._ctx._currentAction;this._ctx._currentAction=this;const n=this._cachedResult;return"object"==typeof n&&"destroy"in n&&"function"==typeof n.destroy&&n.destroy(),this._cachedResult=this._fn(this._ctx),this._cachedClockNumber=e,this._ctx._currentAction=r,!0}_produceIfNeededAt(e){this._producedClockNumber>=e||(this._producerOperations.forEach((t=>t._produceIfNeededAt(e))),this._producedClockNumber=e)}get current(){const e=this._ctx._currentAction;if(!e)throw new Error("It's only possible to read properties from within a reactive context");return e._attachDependency(this),this._runIfNeededAt(this._ctx._currentClockNumber),this._cachedResult}getNonReactively(){return this._cachedResult}}class n{constructor(e,t){this._deps=new Set,this._producedClockNumber=0,this._ctx=e,this._fn=t}_attachDependency(e){this._deps.add(e)}_produceIfNeededAt(e){if(this._producedClockNumber>=e)return;this._producedClockNumber=e,this._deps.forEach((t=>t._runIfNeededAt(e))),this._deps.forEach((t=>t._produceIfNeededAt(e)));const t=this._ctx._currentAction;this._ctx._currentAction=this,this._fn(this._ctx),this._ctx._currentAction=t}}class c{constructor(e,t){this._deps=new Set,this._lastClockNumber=0,this._ctx=e,this._fn=t}_attachDependency(e){this._deps.add(e)}_runIfNeededAt(e){if(this._lastClockNumber>=e)return!0;var t=!1;if(this._deps.forEach((r=>{r._runIfNeededAt(e)&&(t=!0)})),!t&&this._lastClockNumber>0)return!1;const r=this._lastCancelFn;r&&r();const n=this._ctx._currentAction;this._ctx._currentAction=this,this._lastCancelFn=this._fn(this._ctx),this._ctx._currentAction=n,this._lastClockNumber=e}}class o{constructor(e){this._currentClockNumber=1,this._effects=[],this._device=e}get commandEncoder(){return this._commandEncoder}get device(){return this._device}_useProp(e){return new t("function"==typeof e?e():e,this)}_useGPUResource(e){return new r(this,e)}_useGPUUpdate(e,t){const r=new n(this,t);e.forEach((e=>e._attachProducerOperation(r)))}_useEffect(e){this._effects.push(new c(this,e))}}class i{constructor(e){this._renders=[],this._canvasContext=e}addRender(e){this._renders.includes(e)||this._renders.push(e)}outputFrame(e){const t=this._canvasContext.getCurrentTexture();this._renders.forEach((r=>{r.renderTarget.setAndNotify(t),r.runFrame(e,[r.renderTarget])}))}}var s=function(e,t,r,n){return new(r||(r=Promise))((function(c,o){function i(e){try{u(n.next(e))}catch(e){o(e)}}function s(e){try{u(n.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?c(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(i,s)}u((n=n.apply(e,t||[])).next())}))};function u(){var e,t;const r=null===(t=null===(e=navigator.gpu)||void 0===e?void 0:e.getPreferredCanvasFormat)||void 0===t?void 0:t.bind(navigator.gpu);return r?r():"rgba8unorm"}const d="@stage(vertex)\nfn vertexRenderColoredTriangle(\n  @builtin(vertex_index) index: u32\n) ->\n  @builtin(position) vec4<f32>\n{\n  let triangle = array<vec2<f32>, 3>(\n    vec2<f32>(0.0, 0.433),\n    vec2<f32>(-0.5, -0.433),\n    vec2<f32>(0.5, -0.433),\n  );\n\n  return vec4<f32>(triangle[index], 0.0, 1.0);\n}\n\n@stage(fragment)\nfn fragmentRenderColoredTriangle(\n  @builtin(position) pos_in: vec4<f32>\n) ->\n  @location(0) vec4<f32>\n{\n  return vec4<f32>(\n    pos_in.x * 0.003,\n    pos_in.y * 0.003,\n    1.0 - (pos_in.y * 0.003),\n    1.0,\n  );\n}\n";var a;return a=function(e){const t=function(e){return e._useProp(void 0)}(e),r=function(e,t){return e._useGPUResource((e=>e.device.createRenderPipeline({layout:"auto",primitive:{topology:"triangle-list"},vertex:{module:e.device.createShaderModule({code:d}),entryPoint:"vertexRenderColoredTriangle"},fragment:{module:e.device.createShaderModule({code:d}),entryPoint:"fragmentRenderColoredTriangle",targets:[{format:"rgba8unorm"}]}})))}(e);return function(e,n,c){n._useGPUUpdate(e,(e=>{if(!t.current)return;const n=e.commandEncoder.beginRenderPass({colorAttachments:[{view:t.current.createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});n.setPipeline(r.current),n.draw(3,1,0,0),n.end()}))}([t],e),{renderTarget:t}},function(e){(()=>s(this,void 0,void 0,(function*(){const e=yield function(e="high-performance"){return s(this,void 0,void 0,(function*(){if(!navigator.gpu)throw new Error("Your browser doesn't have WebGPU enabled!");const t=yield navigator.gpu.requestAdapter({powerPreference:e});if(!t)throw new Error("Failed to get the GPU adapter!");return t.requestDevice()}))}(),t=yield function(e,t){return s(this,void 0,void 0,(function*(){const r=e.getContext("webgpu");if(!r)throw new Error("Failed to get a WebGPU canvas context!");return r.configure({device:t,format:u(),alphaMode:"opaque",compositingAlphaMode:"opaque"}),r}))}(function(){const e=document.querySelector("canvas.main");if(!e)throw new Error("The main canvas wasn't found in the HTML!");return e}(),e),r=((e,t)=>{const r=function(e,t){const r=new o(e),n=Object.assign(Object.assign({},t(r)),{_ctx:r});return n.runFrame=(e,t)=>{r._currentClockNumber+=1,r._commandEncoder=e;const n=r._currentClockNumber;t.forEach((e=>e._produceIfNeededAt(n))),r._effects.forEach((e=>e._runIfNeededAt(n))),r._commandEncoder=void 0},n}(e,a),n=new i(t);return n.addRender(r),function(e){n.outputFrame(e)}})(e,t);requestAnimationFrame((function t(){!function(e,t){const r=e.createCommandEncoder();t(r),e.queue.submit([r.finish()])}(e,r),requestAnimationFrame(t)}))})))().catch((e=>{document.querySelector("body").innerHTML=e,console.error(e)}))}(),e})()));
//# sourceMappingURL=demo1.js.map