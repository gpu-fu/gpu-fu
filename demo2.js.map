{"version":3,"file":"demo2.js","mappings":"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","sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/webpack/runtime/make namespace object","webpack://beta/../gpu-fu/src/Property.ts","webpack://beta/../gpu-fu/src/Context.ts","webpack://beta/../gpu-fu/src/hooks.ts","webpack://beta/../gpu-fu/src/Unit.ts","webpack://beta/../incubator/src/OutputCanvas.ts","webpack://beta/../incubator/src/VertexSourceRect.ts","webpack://beta/../incubator/src/RenderTextureRect.ts","webpack://beta/../incubator/src/RenderUV.ts","webpack://beta/../incubator/src/RenderUV.wgsl","webpack://beta/../incubator/src/TextureSourceBitmapFromURL.ts","webpack://beta/../incubator/src/TextureSourceBitmap.ts","webpack://beta/./src/runDemo.ts","webpack://beta/./src/demo2.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { ContextImplementation } from \"./Context\"\n\nexport type Property<T> = Pick<\n  PropertyImplementation<T, unknown>,\n  \"current\" | \"readOnly\" | \"set\" | \"change\" | \"mutate\"\n>\n\nexport type PropertyReadOnly<T> = Pick<\n  PropertyImplementation<T, unknown>,\n  \"current\" | \"readOnly\"\n>\n\nexport class PropertyImplementation<T, U> implements Property<T> {\n  private _ctx: ContextImplementation<U>\n  private _current: T\n\n  constructor(initialValue: T, ctx: ContextImplementation<U>) {\n    this._current = initialValue\n    this._ctx = ctx\n  }\n\n  // Get the current value of the property.\n  get current(): T {\n    return this._current\n  }\n\n  // Get a version of this property accessor that can only read (in TypeScript).\n  get readOnly(): PropertyReadOnly<T> {\n    return this\n  }\n\n  // Assign a new value to the property, notifying any reactive effects if\n  // (and only if) the new value is not referentially identical to the old one.\n  //\n  // Use `setAndNotify` instead if you want to unconditionally notify all\n  // downstream reactive effects even if the new value is the same.\n  set(newValue: T) {\n    if (this._current !== newValue) this.setAndNotify(newValue)\n  }\n\n  // Assign a new value to the property, notifying all reactive effects,\n  // regardless of whether the new value is referentially identical to the old.\n  //\n  // Usually you want to use `set` instead, which checks referential identity.\n  setAndNotify(newValue: T) {\n    this._current = newValue\n    this._ctx._needsUnitReRun = true\n  }\n\n  // Use a function to change the value of the property based on the current\n  // value (which will be passed as the argument to the function).\n  //\n  // All reactive effects will be notified if (and only if) the new value\n  // produced by the function is not referentially identical to the old value.\n  //\n  // Use `mutate` instead if the value is an object type that you want to mutate\n  // to change it and trigger reactive effects without actually having to\n  // produce a new referentially new object for the new value.\n  change(fn: (currentValue: T) => T) {\n    this.set(fn(this._current))\n  }\n\n  // Use a function to mutate the current value of the property,\n  // without changing its referential identity.\n  //\n  // All reactive effects will be notified regardless of what the function does.\n  mutate(fn: (currentValue: T) => unknown) {\n    fn(this._current)\n    this._ctx._needsUnitReRun = true // assume mutation always happens\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Unit } from \"./Unit\"\nimport { Property, PropertyImplementation } from \"./Property\"\n\nexport type MaybeDestroyableGPUResource =\n  | undefined\n  | 0\n  | false\n  | null\n  | (GPUObjectBase & { destroy?: () => void })\nexport type StoreItemGPUResource<T extends MaybeDestroyableGPUResource> = [\n  T,\n  unknown[],\n]\n\nexport type StoreItemGPUAction = [\n  (ctx: ContextForGPUAction) => void,\n  unknown[],\n  boolean,\n]\n\nexport type StoreItemEffect = [(() => void) | undefined, unknown[]]\n\nexport class ContextImplementation<U> {\n  private _unitFn: (ctx: Context) => U\n\n  device: GPUDevice\n  commandEncoder?: GPUCommandEncoder\n\n  constructor(unitFn: (ctx: Context) => U, device: GPUDevice) {\n    this._unitFn = unitFn\n    this.device = device\n  }\n\n  ///\n  // This next section relates to private storage of state and effects.\n\n  private _store: unknown[] = []\n  private _storeIndex = 0\n  private _storeUnits: Property<Unit<unknown> | undefined>[] = []\n  private _storeUnitsIndex = 0\n  private _storeGPUActions: StoreItemGPUAction[] = []\n  private _storeGPUActionsIndex = 0\n  _needsUnitReRun = true // TODO: private\n\n  private _nextStoreIndex() {\n    const storeIndex = this._storeIndex\n    this._storeIndex = storeIndex + 1\n    return storeIndex\n  }\n\n  private _nextStoreUnitsIndex() {\n    const storeUnitsIndex = this._storeUnitsIndex\n    this._storeUnitsIndex = storeUnitsIndex + 1\n    return storeUnitsIndex\n  }\n\n  private _nextStoreGPUActionsIndex() {\n    const storeGPUActionsIndex = this._storeGPUActionsIndex\n    this._storeGPUActionsIndex = storeGPUActionsIndex + 1\n    return storeGPUActionsIndex\n  }\n\n  ///\n  // This next section has public methods related to running the unit.\n\n  runUnitIfNeeded(currentUnit: U) {\n    var otherUnitsRan = false\n    this._storeUnits.forEach((unitProp) => {\n      const unit = unitProp.current\n      const otherUnitRan = unit?._ctx.runUnitIfNeeded(unit)\n      if (otherUnitRan) otherUnitsRan = true\n    })\n\n    if (this._needsUnitReRun || otherUnitsRan) {\n      this._storeIndex = 0\n      this._storeUnitsIndex = 0\n      this._storeGPUActionsIndex = 0\n      this._needsUnitReRun = false\n      Object.assign(currentUnit, this._unitFn(this))\n      return true\n    } else {\n      return false\n    }\n  }\n\n  runGPUActionsIfNeeded(commandEncoder: GPUCommandEncoder) {\n    this._storeUnits.forEach((unitProp) => {\n      const unit = unitProp.current\n      unit?._ctx.runGPUActionsIfNeeded(commandEncoder)\n    })\n\n    this.commandEncoder = commandEncoder\n    this._storeGPUActions.forEach(([action, deps, needsRun], index) => {\n      if (needsRun) {\n        action(this as ContextForGPUAction)\n        this._storeGPUActions[index][2] = false\n      }\n    })\n    this.commandEncoder = undefined\n  }\n\n  ///\n  // This next section has public methods\n\n  _useProp<T>(initialValue: (() => T) | T): Property<T> {\n    const storeIndex = this._nextStoreIndex()\n    const existing = this._store[storeIndex] as Property<T>\n\n    // If there is an existing property pair, return it now.\n    if (existing) return existing\n\n    // Otherwise create, store, and return a new prop/setProp pair,\n    // using the provided initial state value or function.\n    const prop: Property<T> = new PropertyImplementation<T, U>(\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue,\n      this,\n    )\n\n    this._store[storeIndex] = prop\n    return prop\n  }\n\n  _useUnitProp<T extends Unit<unknown> | undefined>(\n    initialValue: (() => T) | T,\n  ): Property<T> {\n    const storeIndex = this._nextStoreUnitsIndex()\n    const existing = this._storeUnits[storeIndex] as Property<T>\n\n    // If there is an existing prop/setProp pair, return it now.\n    if (existing) return existing\n\n    // Otherwise create, store, and return a new prop/setProp pair,\n    // using the provided initial state value or function.\n    const prop: Property<T> = new PropertyImplementation<T, U>(\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue,\n      this,\n    )\n\n    this._storeUnits[storeIndex] = prop\n    return prop\n  }\n\n  _useGPUResource<T extends MaybeDestroyableGPUResource>(\n    create: (ctx: ContextForGPUResource) => T,\n    deps: Array<unknown>,\n  ): T {\n    const storeIndex = this._nextStoreIndex()\n    const existing = this._store[storeIndex] as StoreItemGPUResource<T>\n\n    // If the resource has never been created, create it now.\n    if (!existing) {\n      const newResource = create(this)\n      this._store[storeIndex] = [newResource, deps]\n      return newResource\n    }\n\n    // If the resource exists, and all new dependencies have the same identity\n    // as the corresponding old dependencies, return the existing resource.\n    if (deps.every((dep, index) => dep === existing[1][index]))\n      return existing[0]\n\n    // Create the new resource and store it along with its dependencies.\n    const newResource = create(this)\n    const oldResource = existing[0]\n    existing[0] = newResource\n    existing[1] = deps\n\n    // Destroy the old resource if applicable.\n    if (oldResource && typeof oldResource.destroy === \"function\")\n      oldResource.destroy()\n\n    // Return the new resource\n    return newResource\n  }\n\n  _useGPUAction(\n    action: (ctx: ContextForGPUAction) => void,\n    deps: Array<unknown>,\n  ): void {\n    const storeIndex = this._nextStoreGPUActionsIndex()\n    const existing = this._storeGPUActions[storeIndex] as StoreItemGPUAction\n\n    // If the action has never been stored, store it now and return early.\n    if (!existing) {\n      this._storeGPUActions[storeIndex] = [action, deps, true]\n      return\n    }\n\n    // If the action is known, and all new dependencies have the same identity\n    // as the corresponding old dependencies, return without doing anything.\n    if (deps.every((dep, index) => dep === existing[1][index])) return\n\n    // Update the action function along with its dependencies,\n    // and mark it as being \"dirty\" (i.e. in need of being executed again).\n    existing[0] = action\n    existing[1] = deps\n    existing[2] = true\n    return\n  }\n\n  _useEffect(\n    effect: (ctx: ContextEmpty) => (() => void) | undefined,\n    deps: Array<unknown>,\n  ) {\n    const storeIndex = this._nextStoreIndex()\n    const existing = this._store[storeIndex] as StoreItemEffect\n\n    // If the effect has never been stored, store it now after executing.\n    if (!existing) {\n      const cancelFn = effect({})\n      this._store[storeIndex] = [cancelFn, deps]\n      return\n    }\n\n    // If the effect is known, and all new dependencies have the same identity\n    // as the corresponding old dependencies, return without doing anything.\n    if (deps.every((dep, index) => dep === existing[1][index])) return\n\n    // Call the existing cancel function if there is one.\n    if (existing[0]) existing[0]()\n\n    // Execute the effect function to get the new cancel function, then\n    // store it along with the new dependency identities.\n    existing[0] = effect({})\n    existing[1] = deps\n    return\n  }\n}\n\nexport type Context = Pick<\n  ContextImplementation<unknown>,\n  // In the main function context, hooks are available.\n  | \"device\"\n  | \"_useProp\"\n  | \"_useUnitProp\"\n  | \"_useGPUResource\"\n  | \"_useGPUAction\"\n  | \"_useEffect\"\n>\n\nexport type ContextForGPUResource = Pick<\n  ContextImplementation<unknown>,\n  // No hooks are available.\n  \"device\"\n>\n\nexport type ContextForGPUAction = Pick<\n  ContextImplementation<unknown>,\n  // No hooks are available, but a command encoder is available.\n  \"device\"\n> & { commandEncoder: GPUCommandEncoder }\n\nexport type ContextEmpty = {}\n","import {\n  Context,\n  ContextForGPUResource,\n  ContextForGPUAction,\n  MaybeDestroyableGPUResource,\n  ContextEmpty,\n} from \"./Context\"\nimport { Unit, UnitFn, NotAUnit, unit } from \"./Unit\"\nimport { Property } from \"./Property\"\n\nexport function useProp<T>(ctx: Context): Property<NotAUnit<T | undefined>> {\n  return ctx._useProp<T | undefined>(undefined) as Property<\n    NotAUnit<T | undefined>\n  >\n}\n\nexport function useInitializedProp<T>(\n  ctx: Context,\n  initialValue: (() => NotAUnit<T>) | NotAUnit<T>,\n): Property<NotAUnit<T>> {\n  return ctx._useProp<NotAUnit<T>>(initialValue)\n}\n\nexport function useUnitProp<U>(ctx: Context): Property<Unit<U> | undefined> {\n  return ctx._useUnitProp<Unit<U> | undefined>(undefined)\n}\n\nexport function useUnit<U>(ctx: Context, unitFn: UnitFn<U>): Unit<U> {\n  return ctx._useUnitProp<Unit<U>>(() => unit(ctx.device, unitFn)).current\n}\n\nexport function useGPUResource<T extends MaybeDestroyableGPUResource>(\n  ctx: Context,\n  create: (ctx: ContextForGPUResource) => T,\n  deps: Array<unknown>,\n): T {\n  return ctx._useGPUResource<T>(create, deps)\n}\n\nexport function useGPUAction(\n  ctx: Context,\n  action: (ctx: ContextForGPUAction) => void,\n  deps: Array<unknown>,\n): void {\n  ctx._useGPUAction(action, deps)\n}\n\nexport function useEffect<T>(\n  ctx: Context,\n  effect: (ctx: ContextEmpty) => (() => void) | undefined,\n  deps: Array<unknown>,\n) {\n  return ctx._useEffect(effect, deps)\n}\n\nexport function useAsyncPropSetter<T>(\n  ctx: Context,\n  setPropFn: (newValue: T) => unknown,\n  effect: (ctx: ContextEmpty) => Promise<T>,\n  deps: Array<unknown>,\n) {\n  return ctx._useEffect((ctx) => {\n    var cancelled = false\n    effect(ctx)\n      .then((value) => cancelled || setPropFn(value))\n      .catch((error) => {\n        console.error(error)\n        cancelled = true\n      })\n    return () => {\n      cancelled = true\n    }\n  }, deps)\n}\n","import { Context, ContextImplementation } from \"./Context\"\n\nexport type UnitAny = {\n  _ctx: Context\n}\n\nexport type Unit<U> = U & {\n  _ctx: ContextImplementation<U>\n}\n\nexport type UnitRoot<U> = U & {\n  _ctx: ContextImplementation<U>\n  runFrame: (commandEncoder: GPUCommandEncoder) => void\n}\n\nexport type UnitFn<U> = (ctx: Context) => U\n\nexport type NotAUnit<T> = T extends UnitAny ? never : T\n\nexport function unit<U>(\n  device: GPUDevice,\n  unitFn: (ctx: Context) => U,\n): Unit<U> {\n  const ctx = new ContextImplementation<U>(unitFn, device)\n  return { ...unitFn(ctx), _ctx: ctx }\n}\n\nfunction unitFrame<U>(unit: Unit<U>, commandEncoder: GPUCommandEncoder) {\n  const ctx = unit._ctx\n  ctx.runUnitIfNeeded(unit)\n  ctx.runGPUActionsIfNeeded(commandEncoder)\n}\n\nexport function createUnitRoot<U>(\n  device: GPUDevice,\n  unitFn: (ctx: Context) => U,\n): UnitRoot<U> {\n  const ctx = new ContextImplementation<U>(unitFn, device)\n  const unitRoot = { ...unitFn(ctx), _ctx: ctx } as UnitRoot<U>\n  unitRoot.runFrame = (commandEncoder: GPUCommandEncoder) =>\n    unitFrame(unitRoot, commandEncoder)\n  return unitRoot\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Render, UnitRoot } from \"@gpu-fu/gpu-fu\"\n\nexport default class OutputCanvas {\n  _canvasContext: GPUCanvasContext\n  _renders: UnitRoot<Render>[] = []\n\n  constructor(canvasContext: GPUCanvasContext) {\n    this._canvasContext = canvasContext\n  }\n\n  addRender(render: UnitRoot<Render>) {\n    if (this._renders.includes(render)) return\n    this._renders.push(render)\n  }\n\n  outputFrame(commandEncoder: GPUCommandEncoder) {\n    const target = this._canvasContext.getCurrentTexture()\n    this._renders.forEach((render) => {\n      render.renderTarget.set(target)\n      render.runFrame(commandEncoder)\n    })\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, useProp, useGPUAction, useGPUResource } from \"@gpu-fu/gpu-fu\"\n\nconst vertexSourceCount = 6\nconst vertexSourceTotalBytes = 6 * 6 * 4\nconst vertexSourceStrideBytes = 6 * 4\nconst vertexSourceXYZWOffsetBytes = 0\nconst vertexSourceUVOffsetBytes = 4 * 4\n\nexport default function VertexSourceRect(ctx: Context) {\n  const aspectFillRatio = useProp<number>(ctx)\n\n  const buffer = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createBuffer({\n        size: vertexSourceTotalBytes,\n        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n      }),\n    [],\n  )\n\n  useGPUAction(\n    ctx,\n    (ctx) => {\n      if (!buffer) return\n\n      var uMin = 0\n      var uMax = 1\n      var vMin = 0\n      var vMax = 1\n\n      if (aspectFillRatio.current) {\n        if (aspectFillRatio.current < 1) {\n          vMin = 0.5 - 0.5 * aspectFillRatio.current\n          vMax = 1 - vMin\n        } else {\n          uMin = 0.5 - 0.5 / aspectFillRatio.current\n          uMax = 1 - uMin\n        }\n      }\n\n      // prettier-ignore\n      const data = new Float32Array([\n      // (x, y, z, w),  (u, v)\n          1, 1, 0, 1, uMax, vMin,\n         -1,-1, 0, 1, uMin, vMax,\n         -1, 1, 0, 1, uMin, vMin,\n          1, 1, 0, 1, uMax, vMin,\n          1,-1, 0, 1, uMax, vMax,\n         -1,-1, 0, 1, uMin, vMax,\n      ])\n\n      ctx.device.queue.writeBuffer(buffer, 0, data, 0, data.length)\n    },\n    [buffer, aspectFillRatio.current],\n  )\n\n  return {\n    aspectFillRatio,\n    vertexSourceCount,\n    vertexSourceTotalBytes,\n    vertexSourceStrideBytes,\n    vertexSourceXYZWOffsetBytes,\n    vertexSourceUVOffsetBytes,\n    vertexSourceAsGPUBuffer: buffer,\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, useUnit } from \"@gpu-fu/gpu-fu\"\nimport RenderUV from \"./RenderUV\"\nimport VertexSourceRect from \"./VertexSourceRect\"\n\nexport default function RenderTextureRect(ctx: Context) {\n  const { textureSource, vertexSource, renderTarget } = RenderUV(ctx)\n\n  const rect = useUnit(ctx, VertexSourceRect)\n  vertexSource.set(rect)\n\n  // TODO: Use the source texture and target texture aspect ratios\n  // instead of hard-coding a number here.\n  // This doesn't yet work on the latest version of chromium, because\n  // those chromium builds don't yet expose texture width and height.\n  rect.aspectFillRatio.set(850 / 1275)\n\n  return { textureSource, renderTarget }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport {\n  Context,\n  MatrixSource,\n  VertexSource,\n  TextureSource,\n  autoLayout,\n  useProp,\n  useUnitProp,\n  useGPUResource,\n  useGPUAction,\n} from \"@gpu-fu/gpu-fu\"\n\nimport shaderModuleCode from \"./RenderUV.wgsl\"\n\nexport default function RenderUV(ctx: Context) {\n  const cameraSource = useUnitProp<MatrixSource>(ctx)\n  const vertexSource = useUnitProp<VertexSource>(ctx)\n  const textureSource = useUnitProp<TextureSource>(ctx)\n  const renderTarget = useProp<GPUTexture>(ctx)\n\n  const cameraSourceAsGPUBuffer = cameraSource.current?.cameraSourceAsGPUBuffer\n  const textureSourceAsGPUTexture =\n    textureSource.current?.textureSourceAsGPUTexture\n\n  const shaderModule = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createShaderModule({\n        code: shaderModuleCode,\n      }),\n    [],\n  )\n\n  const renderPipeline = useGPUResource(\n    ctx,\n    (ctx) => {\n      if (!vertexSource.current) return\n\n      return ctx.device.createRenderPipeline({\n        vertex: {\n          module: shaderModule,\n          entryPoint: cameraSourceAsGPUBuffer\n            ? \"vertexRenderUVWithMatrix\"\n            : \"vertexRenderUV\",\n          buffers: [\n            {\n              arrayStride: vertexSource.current.vertexSourceStrideBytes,\n              attributes: [\n                {\n                  shaderLocation: 0,\n                  offset: vertexSource.current.vertexSourceXYZWOffsetBytes,\n                  format: \"float32x4\" as GPUVertexFormat,\n                },\n                {\n                  shaderLocation: 1,\n                  offset: vertexSource.current.vertexSourceUVOffsetBytes,\n                  format: \"float32x2\" as GPUVertexFormat,\n                },\n              ],\n            },\n          ],\n        },\n        fragment: {\n          module: shaderModule,\n          entryPoint: \"fragmentRenderUV\",\n          targets: [\n            {\n              // TODO: Remove this hard-coded value - get the real one somehow.\n              format: \"rgba8unorm\" as GPUTextureFormat,\n            },\n          ],\n        },\n        primitive: {\n          topology: \"triangle-list\",\n          // TODO: Configurable `cullMode`\n        },\n        depthStencil: {\n          depthWriteEnabled: true,\n          depthCompare: \"less\",\n          format: \"depth24plus\",\n        },\n        layout: autoLayout(),\n      })\n    },\n    [shaderModule, vertexSource.current],\n  )\n\n  const sampler = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createSampler({\n        magFilter: \"linear\",\n        minFilter: \"linear\",\n      }),\n    [],\n  )\n\n  const bindGroup = useGPUResource(\n    ctx,\n    (ctx) => {\n      if (!renderPipeline) return\n      if (!textureSourceAsGPUTexture) return\n\n      const entries: GPUBindGroupEntry[] = [\n        {\n          binding: 1,\n          resource: sampler,\n        },\n        {\n          binding: 2,\n          resource: textureSourceAsGPUTexture.createView(),\n        },\n      ]\n      if (cameraSourceAsGPUBuffer)\n        entries.unshift({\n          binding: 0,\n          resource: { buffer: cameraSourceAsGPUBuffer },\n        })\n\n      return ctx.device.createBindGroup({\n        layout: renderPipeline.getBindGroupLayout(0),\n        entries,\n      })\n    },\n\n    [\n      renderPipeline,\n      cameraSourceAsGPUBuffer,\n      textureSourceAsGPUTexture,\n      sampler,\n    ],\n  )\n\n  const depthTexture = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createTexture({\n        size: [300, 300], // TODO: somehow get from canvas client size\n        format: \"depth24plus\",\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      }),\n    [],\n  )\n\n  useGPUAction(\n    ctx,\n    (ctx) => {\n      if (!vertexSource.current) return\n      if (!renderTarget.current) return\n      if (!renderPipeline) return\n      if (!bindGroup) return\n\n      const passEncoder = ctx.commandEncoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: renderTarget.current.createView(),\n            clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n            loadOp: \"clear\" as GPULoadOp,\n            storeOp: \"store\" as GPUStoreOp,\n          },\n        ],\n        depthStencilAttachment: {\n          view: depthTexture.createView(),\n          depthClearValue: 1.0,\n          depthLoadOp: \"clear\" as GPULoadOp,\n          depthStoreOp: \"store\" as GPUStoreOp,\n        },\n      })\n      passEncoder.setPipeline(renderPipeline)\n      passEncoder.setVertexBuffer(\n        0,\n        vertexSource.current.vertexSourceAsGPUBuffer,\n      )\n      passEncoder.setBindGroup(0, bindGroup)\n      passEncoder.draw(vertexSource.current.vertexSourceCount, 1, 0, 0)\n      passEncoder.end()\n    },\n    [vertexSource.current, renderTarget.current, renderPipeline, bindGroup],\n  )\n\n  return {\n    cameraSource,\n    textureSource,\n    vertexSource,\n    renderTarget,\n  }\n}\n","export default \"@group(0) @binding(0) var<uniform> use_matrix: mat4x4<f32>;\\n@group(0) @binding(1) var use_sampler: sampler;\\n@group(0) @binding(2) var use_texture: texture_2d<f32>;\\n\\nstruct VertexOutput {\\n  @builtin(position) pos: vec4<f32>;\\n  @location(0) uv: vec2<f32>;\\n}\\n\\n@stage(vertex)\\nfn vertexRenderUV(\\n  @location(0) pos_in: vec4<f32>,\\n  @location(1) uv_in: vec2<f32>,\\n) ->\\n  VertexOutput\\n{\\n  var out: VertexOutput;\\n  out.pos = pos_in;\\n  out.uv = uv_in;\\n  return out;\\n}\\n\\n@stage(vertex)\\nfn vertexRenderUVWithMatrix(\\n  @location(0) pos_in: vec4<f32>,\\n  @location(1) uv_in: vec2<f32>,\\n) ->\\n  VertexOutput\\n{\\n  var out: VertexOutput;\\n  out.pos = use_matrix * pos_in;\\n  out.uv = uv_in;\\n  return out;\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderUV(\\n  @location(0) uv_in : vec2<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return textureSample(use_texture, use_sampler, uv_in.xy);\\n}\\n\";","import { Context, useAsyncPropSetter, useProp } from \"@gpu-fu/gpu-fu\"\nimport TextureSourceBitmap from \"./TextureSourceBitmap\"\n\nexport default function TextureSourceBitmapFromURL(ctx: Context) {\n  const { imageBitmap, label, textureSourceAsGPUTexture } =\n    TextureSourceBitmap(ctx)\n\n  // Use the existing label property for a dual-purpose.\n  // We use it as the URL to fetch from (though this implies\n  // the assumption that the label will always be equal to the URL).\n  const url = label\n\n  useAsyncPropSetter(\n    ctx,\n    imageBitmap.set.bind(imageBitmap),\n    async (ctx) => {\n      if (!url.current) return\n      const img = document.createElement(\"img\")\n      img.src = url.current\n      await img.decode()\n      const imageBitmap = await createImageBitmap(img)\n      return imageBitmap\n    },\n    [url.current],\n  )\n\n  return {\n    url,\n    textureSourceAsGPUTexture,\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { Context, useProp, useGPUResource, useGPUAction } from \"@gpu-fu/gpu-fu\"\n\nexport default function TextureSourceBitmap(ctx: Context) {\n  const imageBitmap = useProp<ImageBitmap>(ctx)\n  const label = useProp<string>(ctx)\n\n  const textureWidth = imageBitmap.current?.width ?? 16 // TODO: remove fallback values\n  const textureHeight = imageBitmap.current?.height ?? 16 // TODO: remove fallback values\n\n  const texture = useGPUResource(\n    ctx,\n    (ctx) =>\n      ctx.device.createTexture({\n        label: label.current,\n        size: [textureWidth, textureHeight, 1],\n        format: \"rgba8unorm\",\n        usage:\n          GPUTextureUsage.TEXTURE_BINDING |\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT,\n      }),\n    [textureWidth, textureHeight, label.current],\n  )\n\n  useGPUAction(\n    ctx,\n    (ctx) => {\n      if (!imageBitmap.current) return\n      if (!texture) return\n\n      ctx.device.queue.copyExternalImageToTexture(\n        { source: imageBitmap.current },\n        { texture: texture },\n        [imageBitmap.current.width, imageBitmap.current.height],\n      )\n    },\n    [imageBitmap.current, texture],\n  )\n\n  return {\n    imageBitmap,\n    label,\n    textureSourceAsGPUTexture: texture,\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { UnitFn, createUnitRoot, Render } from \"@gpu-fu/gpu-fu\"\nimport { OutputCanvas } from \"@gpu-fu/incubator\"\n\ntype FrameFn = (commandEncoder: GPUCommandEncoder) => void\ntype SetupFn = (device: GPUDevice, canvasContext: GPUCanvasContext) => FrameFn\n\nexport default function runDemo(renderFn: UnitFn<Render>) {\n  runDemoInner((device, canvasContext) => {\n    const render = createUnitRoot(device, renderFn)\n\n    const output = new OutputCanvas(canvasContext)\n    output.addRender(render)\n\n    return function frame(commandEncoder) {\n      output.outputFrame(commandEncoder)\n    }\n  })\n}\n\nfunction runDemoInner(setupFn: SetupFn) {\n  ;(async () => {\n    const device = await getDevice()\n    const canvasContext = await getCanvasContext(getDemoCanvas(), device)\n\n    const frameFn = setupFn(device, canvasContext)\n\n    function repeatFrameWithContext() {\n      runFrameWithContext(device, frameFn)\n      requestAnimationFrame(repeatFrameWithContext)\n    }\n    requestAnimationFrame(repeatFrameWithContext)\n  })().catch((error) => {\n    document.querySelector(\"body\")!.innerHTML = error\n    console.error(error)\n  })\n}\n\nasync function getDevice(\n  powerPreference: GPUPowerPreference = \"high-performance\",\n): Promise<GPUDevice> {\n  if (!navigator.gpu)\n    throw new Error(\"Your browser doesn't have WebGPU enabled!\")\n\n  const gpu = await navigator.gpu.requestAdapter({ powerPreference })\n  if (!gpu) throw new Error(\"Failed to get the GPU adapter!\")\n\n  return gpu.requestDevice()\n}\n\nexport function getDemoCanvas(): HTMLCanvasElement {\n  const canvas = document.querySelector(\n    \"canvas.main\",\n  ) as HTMLCanvasElement | null\n  if (!canvas) throw new Error(\"The main canvas wasn't found in the HTML!\")\n\n  return canvas\n}\n\nasync function getCanvasContext(\n  canvas: HTMLCanvasElement,\n  device: GPUDevice,\n): Promise<GPUCanvasContext> {\n  const canvasContext = canvas.getContext(\"webgpu\") as GPUCanvasContext | null\n  if (!canvasContext) throw new Error(\"Failed to get a WebGPU canvas context!\")\n\n  canvasContext.configure({\n    device,\n    format: getPreferredCanvasFormat(),\n    alphaMode: \"opaque\",\n  })\n\n  return canvasContext\n}\n\nfunction getPreferredCanvasFormat() {\n  // Some browsers throw an \"Illegal invocation\" error if we don't bind.\n  const getPreferredCanvasFormat =\n    navigator.gpu?.getPreferredCanvasFormat?.bind(navigator.gpu)\n  if (getPreferredCanvasFormat) return getPreferredCanvasFormat()\n\n  // Hard-coded default for browsers that don't implement this function yet.\n  return \"rgba8unorm\"\n}\n\nfunction runFrameWithContext(device: GPUDevice, frameFn: FrameFn) {\n  const commandEncoder = device.createCommandEncoder()\n  frameFn(commandEncoder)\n  device.queue.submit([commandEncoder.finish()])\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport { useUnit } from \"@gpu-fu/gpu-fu\"\nimport {\n  RenderTextureRect,\n  TextureSourceBitmapFromURL,\n} from \"@gpu-fu/incubator\"\n\nimport runDemo from \"./runDemo\"\nrunDemo((ctx) => {\n  const textureSource = useUnit(ctx, TextureSourceBitmapFromURL)\n  textureSource.url.set(\"./assets/fireweed.jpg\")\n\n  const { renderTarget, ...render } = useUnit(ctx, RenderTextureRect)\n  render.textureSource.set(textureSource)\n\n  return { renderTarget }\n})\n"],"names":["root","factory","exports","module","define","amd","self","this","Symbol","toStringTag","Object","defineProperty","value","PropertyImplementation","constructor","initialValue","ctx","_current","_ctx","current","readOnly","set","newValue","setAndNotify","_needsUnitReRun","change","fn","mutate","ContextImplementation","unitFn","device","_store","_storeIndex","_storeUnits","_storeUnitsIndex","_storeGPUActions","_storeGPUActionsIndex","_unitFn","_nextStoreIndex","storeIndex","_nextStoreUnitsIndex","storeUnitsIndex","_nextStoreGPUActionsIndex","storeGPUActionsIndex","runUnitIfNeeded","currentUnit","otherUnitsRan","forEach","unitProp","unit","assign","runGPUActionsIfNeeded","commandEncoder","action","deps","needsRun","index","undefined","_useProp","existing","prop","_useUnitProp","_useGPUResource","create","newResource","every","dep","oldResource","destroy","_useGPUAction","_useEffect","effect","cancelFn","useUnitProp","useUnit","OutputCanvas","canvasContext","_renders","_canvasContext","addRender","render","includes","push","outputFrame","target","getCurrentTexture","renderTarget","runFrame","VertexSourceRect","aspectFillRatio","buffer","createBuffer","size","usage","GPUBufferUsage","VERTEX","COPY_DST","uMin","uMax","vMin","vMax","data","Float32Array","queue","writeBuffer","length","vertexSourceCount","vertexSourceTotalBytes","vertexSourceStrideBytes","vertexSourceXYZWOffsetBytes","vertexSourceUVOffsetBytes","vertexSourceAsGPUBuffer","RenderTextureRect","textureSource","vertexSource","cameraSource","cameraSourceAsGPUBuffer","textureSourceAsGPUTexture","shaderModule","createShaderModule","code","renderPipeline","createRenderPipeline","vertex","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","format","fragment","targets","primitive","topology","depthStencil","depthWriteEnabled","depthCompare","layout","autoLayout","sampler","createSampler","magFilter","minFilter","bindGroup","entries","binding","resource","createView","unshift","createBindGroup","getBindGroupLayout","depthTexture","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","passEncoder","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","setPipeline","setVertexBuffer","setBindGroup","draw","end","rect","TextureSourceBitmapFromURL","imageBitmap","label","textureWidth","width","textureHeight","height","texture","TEXTURE_BINDING","copyExternalImageToTexture","source","TextureSourceBitmap","url","setPropFn","cancelled","then","catch","error","console","useAsyncPropSetter","bind","img","document","createElement","src","decode","createImageBitmap","getPreferredCanvasFormat","navigator","gpu","renderFn","setupFn","powerPreference","Error","requestAdapter","requestDevice","getDevice","canvas","getContext","configure","alphaMode","getCanvasContext","querySelector","getDemoCanvas","frameFn","unitRoot","unitFrame","createUnitRoot","output","requestAnimationFrame","repeatFrameWithContext","createCommandEncoder","submit","finish","runFrameWithContext","innerHTML","runDemoInner"],"sourceRoot":""}