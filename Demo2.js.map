{"version":3,"file":"Demo2.js","mappings":"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","sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/webpack/runtime/make namespace object","webpack://beta/./src/common/runDemo.ts","webpack://beta/./src/gpu-fu/TextureSourceBitmap.ts","webpack://beta/./src/gpu-fu/RenderUV.ts","webpack://beta/./src/gpu-fu/RenderUV.wgsl","webpack://beta/./src/gpu-fu/VertexSourceRect.ts","webpack://beta/./src/gpu-fu/RenderTextureRect.ts","webpack://beta/./src/gpu-fu/OutputCanvas.ts","webpack://beta/./src/Demo2/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"../gpu-fu/Context\"\n\ntype FrameFn = (ctx: Context, frame: number) => void\ntype SetupFn = (\n  device: GPUDevice,\n  canvasContext: GPUCanvasContext\n) => Promise<FrameFn>\n\nexport default function runDemo(setupFn: SetupFn) {\n  ;(async () => {\n    const device = await getDevice()\n    const canvasContext = await getCanvasContext(\"canvas.main\", device)\n\n    const frameFn = await setupFn(device, canvasContext)\n\n    var frame = 0\n    function repeatFrameWithContext() {\n      frame = frame + 1\n      runFrameWithContext(device, frame, frameFn)\n      requestAnimationFrame(repeatFrameWithContext)\n    }\n    requestAnimationFrame(repeatFrameWithContext)\n  })().catch((error) => {\n    document.querySelector(\"body\")!.innerHTML = error\n    console.error(error)\n  })\n}\n\nasync function getDevice(\n  powerPreference: GPUPowerPreference = \"high-performance\"\n): Promise<GPUDevice> {\n  if (!navigator.gpu)\n    throw new Error(\"Your browser doesn't have WebGPU enabled!\")\n\n  const gpu = await navigator.gpu.requestAdapter({ powerPreference })\n  if (!gpu) throw new Error(\"Failed to get the GPU adapter!\")\n\n  return gpu.requestDevice()\n}\n\nasync function getCanvasContext(\n  querySelector: string,\n  device: GPUDevice\n): Promise<GPUCanvasContext> {\n  const canvas = document.querySelector(\n    querySelector\n  ) as HTMLCanvasElement | null\n  if (!canvas) throw new Error(\"The main canvas wasn't found in the HTML!\")\n\n  const canvasContext = canvas.getContext(\"webgpu\") as GPUCanvasContext | null\n  if (!canvasContext) throw new Error(\"Failed to get a WebGPU canvas context!\")\n\n  canvasContext.configure({\n    device,\n    format: getPreferredCanvasFormat(),\n    alphaMode: \"opaque\",\n  })\n\n  return canvasContext\n}\n\nfunction getPreferredCanvasFormat() {\n  // Some browsers throw an \"Illegal invocation\" error if we don't bind.\n  const getPreferredCanvasFormat =\n    navigator.gpu?.getPreferredCanvasFormat?.bind(navigator.gpu)\n  if (getPreferredCanvasFormat) return getPreferredCanvasFormat()\n\n  // Hard-coded default for browsers that don't implement this function yet.\n  return \"rgba8unorm\"\n}\n\nfunction runFrameWithContext(\n  device: GPUDevice,\n  frame: number,\n  frameFn: FrameFn\n) {\n  const commandEncoder = device.createCommandEncoder()\n  frameFn({ device, commandEncoder }, frame)\n  device.queue.submit([commandEncoder.finish()])\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport TextureSource from \"./TextureSource\"\n\nexport default class TextureSourceBitmap implements TextureSource {\n  private _imageBitmap: ImageBitmap\n  private _label: string\n\n  private _texture?: GPUTexture\n\n  constructor(imageBitmap: ImageBitmap, label: string) {\n    this._imageBitmap = imageBitmap\n    this._label = label\n  }\n\n  static async fromURL(url: string, label?: string) {\n    const img = document.createElement(\"img\")\n    img.src = url\n    await img.decode()\n    const imageBitmap = await createImageBitmap(img)\n    return new TextureSourceBitmap(imageBitmap, label ?? url)\n  }\n\n  textureSourceAsGPUTexture(ctx: Context): GPUTexture {\n    if (this._texture) return this._texture\n\n    this._texture = ctx.device.createTexture({\n      label: this._label,\n      size: [this._imageBitmap.width, this._imageBitmap.height, 1],\n      format: \"rgba8unorm\",\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    })\n\n    ctx.device.queue.copyExternalImageToTexture(\n      { source: this._imageBitmap },\n      { texture: this._texture },\n      [this._imageBitmap.width, this._imageBitmap.height]\n    )\n\n    console.log(this._texture)\n\n    return this._texture\n  }\n\n  textureSourceFrame(ctx: Context, frame: number): void {}\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport Render from \"./Render\"\nimport VertexSource from \"./VertexSource\"\nimport TextureSource from \"./TextureSource\"\n\nimport shaderModuleCode from \"./RenderUV.wgsl\"\nimport { autoLayout } from \"./utils\"\n\nexport default class RenderUV implements Render {\n  private _vertexSource?: VertexSource\n  private _textureSource?: TextureSource\n\n  private _shaderModule?: GPUShaderModule\n  private _renderPipeline?: GPURenderPipeline\n  private _bindGroup?: GPUBindGroup\n\n  getVertexSource(): VertexSource {\n    if (this._vertexSource) return this._vertexSource\n    throw new Error(`${this} has no _vertexSource`)\n  }\n\n  setVertexSource(vertexSource: VertexSource) {\n    this._vertexSource = vertexSource\n    this._renderPipeline = undefined\n    this._bindGroup = undefined\n  }\n\n  getTextureSource(): TextureSource {\n    if (this._textureSource) return this._textureSource\n    throw new Error(`${this} has no _textureSource`)\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._textureSource = textureSource\n    this._renderPipeline = undefined\n    this._bindGroup = undefined\n  }\n\n  getShaderModule(ctx: Context): GPUShaderModule {\n    if (this._shaderModule) return this._shaderModule\n\n    return (this._shaderModule = ctx.device.createShaderModule({\n      code: shaderModuleCode,\n    }))\n  }\n\n  getRenderPipeline(ctx: Context): GPURenderPipeline {\n    if (this._renderPipeline) return this._renderPipeline\n\n    const vertexSource = this.getVertexSource()\n\n    return (this._renderPipeline = ctx.device.createRenderPipeline({\n      vertex: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"vertexRenderUV\",\n        buffers: [\n          {\n            arrayStride: vertexSource.vertexSourceStrideBytes(ctx),\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: vertexSource.vertexSourceXYZWOffsetBytes(ctx),\n                format: \"float32x4\" as GPUVertexFormat,\n              },\n              {\n                shaderLocation: 1,\n                offset: vertexSource.vertexSourceUVOffsetBytes(ctx),\n                format: \"float32x2\" as GPUVertexFormat,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: this.getShaderModule(ctx),\n        entryPoint: \"fragmentRenderUV\",\n        targets: [\n          {\n            // TODO: Remove this hard-coded value - get the real one somehow.\n            format: \"rgba8unorm\" as GPUTextureFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: \"triangle-list\",\n      },\n      layout: autoLayout(),\n    }))\n  }\n\n  getBindGroup(ctx: Context) {\n    if (this._bindGroup) return this._bindGroup\n\n    const sampler = ctx.device.createSampler({\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n    })\n\n    return (this._bindGroup = ctx.device.createBindGroup({\n      layout: this.getRenderPipeline(ctx).getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: sampler,\n        },\n        {\n          binding: 1,\n          resource: this.getTextureSource()\n            .textureSourceAsGPUTexture(ctx)\n            .createView(),\n        },\n      ],\n    }))\n  }\n\n  renderFrame(ctx: Context, frame: number, target: GPUTexture): void {\n    this.getTextureSource().textureSourceFrame(ctx, frame)\n    const vertexCount = this.getVertexSource().vertexSourceFrame(ctx, frame)\n\n    const passEncoder = ctx.commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: target.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: \"clear\" as GPULoadOp,\n          storeOp: \"store\" as GPUStoreOp,\n        },\n      ],\n    })\n    passEncoder.setPipeline(this.getRenderPipeline(ctx))\n    passEncoder.setVertexBuffer(\n      0,\n      this.getVertexSource().vertexSourceAsGPUBuffer(ctx)\n    )\n    passEncoder.setBindGroup(0, this.getBindGroup(ctx))\n    passEncoder.draw(vertexCount, 1, 0, 0)\n    passEncoder.end()\n  }\n}\n","export default \"@group(0) @binding(0) var use_sampler: sampler;\\n@group(0) @binding(1) var use_texture: texture_2d<f32>;\\n\\nstruct VertexOutput {\\n  @builtin(position) pos: vec4<f32>;\\n  @location(0) uv: vec2<f32>;\\n}\\n\\n@stage(vertex)\\nfn vertexRenderUV(\\n  @location(0) pos_in: vec4<f32>,\\n  @location(1) uv_in: vec2<f32>,\\n) ->\\n  VertexOutput\\n{\\n  var out: VertexOutput;\\n  out.pos = pos_in;\\n  out.uv = uv_in;\\n  return out;\\n}\\n\\n@stage(fragment)\\nfn fragmentRenderUV(\\n  @location(0) uv_in : vec2<f32>\\n) ->\\n  @location(0) vec4<f32>\\n{\\n  return textureSample(use_texture, use_sampler, uv_in.xy);\\n}\\n\";","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport VertexSource from \"./VertexSource\"\n\nexport default class VertexSourceRect implements VertexSource {\n  private _aspectFillRatio?: number\n\n  private _buffer?: GPUBuffer\n  private _bufferUpToDate = false\n\n  setAspectFillRatio(ratio: number) {\n    if (this._aspectFillRatio === ratio) return\n    this._aspectFillRatio = ratio\n    this._bufferUpToDate = false\n  }\n\n  private getBuffer(ctx: Context): GPUBuffer {\n    if (this._buffer) return this._buffer\n\n    const buffer = ctx.device.createBuffer({\n      size: this.vertexSourceTotalBytes(ctx),\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    })\n\n    return (this._buffer = buffer)\n  }\n\n  private updateBuffer(ctx: Context) {\n    if (this._bufferUpToDate) return\n\n    var uMin = 0\n    var uMax = 1\n    var vMin = 0\n    var vMax = 1\n\n    if (this._aspectFillRatio) {\n      if (this._aspectFillRatio < 1) {\n        vMin = 0.5 - 0.5 * this._aspectFillRatio\n        vMax = 1 - vMin\n      } else {\n        uMin = 0.5 - 0.5 / this._aspectFillRatio\n        uMax = 1 - uMin\n      }\n    }\n\n    // prettier-ignore\n    const data = new Float32Array([\n    // (x, y, z, w),  (u, v)\n        1, 1, 0, 1, uMax, vMin,\n       -1,-1, 0, 1, uMin, vMax,\n       -1, 1, 0, 1, uMin, vMin,\n        1, 1, 0, 1, uMax, vMin,\n        1,-1, 0, 1, uMax, vMax,\n       -1,-1, 0, 1, uMin, vMax,\n    ])\n\n    ctx.device.queue.writeBuffer(this.getBuffer(ctx), 0, data, 0, data.length)\n\n    this._bufferUpToDate = true\n  }\n\n  vertexSourceAsGPUBuffer(ctx: Context): GPUBuffer {\n    return this.getBuffer(ctx)\n  }\n\n  vertexSourceTotalBytes = (ctx: Context) => 6 * 6 * 4\n  vertexSourceStrideBytes = (ctx: Context) => 6 * 4\n  vertexSourceXYZWOffsetBytes = (ctx: Context) => 0\n  vertexSourceUVOffsetBytes = (ctx: Context) => 4 * 4\n\n  vertexSourceFrame(ctx: Context, frame: number) {\n    this.updateBuffer(ctx)\n    return 6\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport Render from \"./Render\"\nimport RenderUV from \"./RenderUV\"\nimport TextureSource from \"./TextureSource\"\nimport VertexSourceRect from \"./VertexSourceRect\"\n\nexport default class RenderTextureRect implements Render {\n  private _renderUV = new RenderUV()\n\n  constructor() {\n    this._renderUV.setVertexSource(new VertexSourceRect())\n  }\n\n  setTextureSource(textureSource: TextureSource) {\n    this._renderUV.setTextureSource(textureSource)\n  }\n\n  renderFrame(ctx: Context, frame: number, target: GPUTexture): void {\n    // TODO : Use the source texture and target texture aspect ratios\n    // instead of hard-coding a number here.\n    // This doesn't yet work on the latest version of chromium, because\n    // those chromium builds don't yet expose texture width and height.\n    ;(this._renderUV.getVertexSource() as VertexSourceRect).setAspectFillRatio(\n      850 / 1275\n    )\n    this._renderUV.renderFrame(ctx, frame, target)\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport Context from \"./Context\"\nimport Render from \"./Render\"\n\nexport default class OutputCanvas {\n  _canvasContext: GPUCanvasContext\n  _renders: Render[] = []\n\n  constructor(canvasContext: GPUCanvasContext) {\n    this._canvasContext = canvasContext\n  }\n\n  addRender(render: Render) {\n    if (this._renders.includes(render)) return\n    this._renders.push(render)\n  }\n\n  outputFrame(ctx: Context, frame: number) {\n    const target = this._canvasContext.getCurrentTexture()\n    this._renders.forEach((render) => {\n      render.renderFrame(ctx, frame, target)\n    })\n  }\n}\n","/// <reference types=\"@webgpu/types\" />\n\nimport runDemo from \"../common/runDemo\"\n\nimport TextureSourceBitmap from \"../gpu-fu/TextureSourceBitmap\"\nimport RenderTextureRect from \"../gpu-fu/RenderTextureRect\"\nimport OutputCanvas from \"../gpu-fu/OutputCanvas\"\n\nrunDemo(async (device, canvasContext) => {\n  const textureSource = await TextureSourceBitmap.fromURL(\n    \"./assets/fireweed.jpg\"\n  )\n\n  const renderUV = new RenderTextureRect()\n  renderUV.setTextureSource(textureSource)\n\n  const output = new OutputCanvas(canvasContext)\n  output.addRender(renderUV)\n\n  console.log(canvasContext.getCurrentTexture())\n\n  return function frame(ctx, frame) {\n    output.outputFrame(ctx, frame)\n  }\n})\n"],"names":["root","factory","exports","module","define","amd","self","this","Symbol","toStringTag","Object","defineProperty","value","getDevice","powerPreference","navigator","gpu","Error","requestAdapter","requestDevice","getCanvasContext","querySelector","device","canvas","document","canvasContext","getContext","configure","format","getPreferredCanvasFormat","alphaMode","bind","imageBitmap","label","_imageBitmap","_label","fromURL","url","img","createElement","src","decode","createImageBitmap","TextureSourceBitmap","textureSourceAsGPUTexture","ctx","_texture","createTexture","size","width","height","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","queue","copyExternalImageToTexture","source","texture","console","log","textureSourceFrame","frame","getVertexSource","_vertexSource","setVertexSource","vertexSource","_renderPipeline","undefined","_bindGroup","getTextureSource","_textureSource","setTextureSource","textureSource","getShaderModule","_shaderModule","createShaderModule","code","getRenderPipeline","createRenderPipeline","vertex","entryPoint","buffers","arrayStride","vertexSourceStrideBytes","attributes","shaderLocation","offset","vertexSourceXYZWOffsetBytes","vertexSourceUVOffsetBytes","fragment","targets","primitive","topology","layout","autoLayout","getBindGroup","sampler","createSampler","magFilter","minFilter","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","renderFrame","target","vertexCount","vertexSourceFrame","passEncoder","commandEncoder","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","setVertexBuffer","vertexSourceAsGPUBuffer","setBindGroup","draw","end","_bufferUpToDate","vertexSourceTotalBytes","setAspectFillRatio","ratio","_aspectFillRatio","getBuffer","_buffer","buffer","createBuffer","GPUBufferUsage","VERTEX","updateBuffer","uMin","uMax","vMin","vMax","data","Float32Array","writeBuffer","length","_renderUV","_renders","_canvasContext","addRender","render","includes","push","outputFrame","getCurrentTexture","forEach","setupFn","repeatFrameWithContext","frameFn","createCommandEncoder","submit","finish","runFrameWithContext","requestAnimationFrame","error","innerHTML","runDemo","renderUV","output"],"sourceRoot":""}